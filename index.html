<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prototyp FPS WebGL v3 - Zmiany</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #222; color: white; font-family: sans-serif; }
        canvas { display: block; }
        #hud {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            color: white;
            font-size: 18px;
            z-index: 10;
        }
        #crosshair {
            position: absolute;
            left: 50%;
            top: 50%;
            width: 2px;
            height: 10px;
            background-color: lime;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 10;
        }
         #crosshair::before {
            content: '';
            position: absolute;
            left: -4px;
            top: 4px;
            width: 10px;
            height: 2px;
            background-color: lime;
         }

         .player-label {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.6);
            color: white;
            padding: 2px 5px;
            border-radius: 3px;
            font-size: 12px;
            white-space: nowrap;
            pointer-events: none;
            transform: translateX(-50%);
            text-align: center;
            z-index: 5;
        }
        .health-bar {
            height: 5px;
            background-color: red;
            margin-top: 2px;
        }
         .health-bar-inner {
            height: 100%;
            background-color: lime;
            width: 100%;
         }
         #scoreboard {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.75);
            border: 1px solid #555;
            border-radius: 8px;
            padding: 15px;
            color: white;
            font-size: 14px;
            min-width: 300px;
            z-index: 20;
            display: none;
         }
         #scoreboard table { width: 100%; border-collapse: collapse; }
         #scoreboard th, #scoreboard td { padding: 5px 8px; text-align: left; border-bottom: 1px solid #444; }
         #scoreboard th { font-weight: bold; }
         #scoreboard tr:last-child td { border-bottom: none; }
         #scoreboard .local-player td { font-weight: bold; color: #aaffaa; }

         #connection-status {
             position: absolute;
             top: 10px;
             left: 10px;
             color: #ffcc00;
             background-color: rgba(0,0,0,0.5);
             padding: 5px;
             border-radius: 3px;
             font-size: 12px;
             z-index: 10;
         }

         #event-log {
             position: absolute;
             top: 10px;
             right: 10px;
             width: 250px;
             max-height: 150px;
             overflow: hidden;
             display: flex;
             flex-direction: column-reverse;
             z-index: 15;
         }
         .log-message {
             background-color: rgba(0, 0, 0, 0.6);
             color: #eee;
             padding: 4px 8px;
             margin-top: 4px;
             border-radius: 4px;
             font-size: 12px;
             white-space: nowrap;
             overflow: hidden;
             text-overflow: ellipsis;
             animation: fadeOut 5s forwards;
         }
         .log-message.join { color: #88ff88; }
         .log-message.leave { color: #ff8888; }
         .log-message.kill { color: #ffffff; }
         .log-message.kill .attacker { color: #ffdd88; font-weight: bold; }
         .log-message.kill .victim { color: #88ddff; font-weight: bold; }

         @keyframes fadeOut {
             0% { opacity: 1; }
             80% { opacity: 1; }
             100% { opacity: 0; }
         }

         /* Nowe style: Serca, Przeładowanie, Ekran śmierci */
        #top-right-hud {
            position: absolute;
            top: 10px;
            right: 10px; /* Przesunięty nieco przez event-log */
            display: flex;
            flex-direction: column;
            align-items: flex-end; /* Elementy wyrównane do prawej */
            z-index: 16; /* Nad event-log */
        }

         #health-hearts {
             display: flex;
             margin-bottom: 5px; /* Odstęp od logu */
         }

         .heart {
             width: 20px;
             height: 18px;
             margin-left: 3px;
             background-size: contain;
             background-repeat: no-repeat;
             background-position: center;
         }

         .heart-full {
             background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="red"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/></svg>');
         }

         .heart-empty {
              background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/></svg>');
         }

         #reload-status {
            position: absolute; /* Pozycjonowanie względem body */
            top: 60%; /* Poniżej środka */
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px 15px;
            border-radius: 5px;
            font-size: 16px;
            z-index: 12; /* Nad HUD, pod celownikiem */
            display: none; /* Domyślnie ukryte */
            text-align: center;
            min-width: 150px;
         }
         #reload-progress-bar-container {
            width: 100%;
            height: 8px;
            background-color: #555;
            border-radius: 4px;
            margin-top: 5px;
            overflow: hidden; /* Ukryj część paska, która wychodzi poza kontener */
         }
          #reload-progress-bar {
             width: 0%; /* Początkowo puste */
             height: 100%;
             background-color: #4CAF50; /* Zielony pasek */
             border-radius: 4px;
             transition: width 0.1s linear; /* Płynne wypełnianie */
          }

         #death-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(150, 0, 0, 0.7); /* Półprzezroczysty czerwony */
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            z-index: 50; /* Nad wszystkim */
            display: none; /* Domyślnie ukryty */
            text-align: center;
         }
         #death-message {
             font-size: 36px;
             margin-bottom: 10px;
         }
         #killer-info {
             font-size: 20px;
             margin-bottom: 20px;
         }
         #respawn-timer {
             font-size: 28px;
             font-weight: bold;
         }

    </style>
</head>
<body>
    <div id="connection-status">Łączenie...</div>
    <div id="hud">
        <!-- Usunięto stare info o zdrowiu -->
        Amunicja: <span id="ammo">30 / 100</span>
    </div>
    <!-- Nowy HUD w prawym górnym rogu -->
    <div id="top-right-hud">
         <div id="health-hearts">
             <!-- Serca będą dodawane dynamicznie -->
         </div>
         <!-- Event log przeniesiony poniżej serc -->
         <div id="event-log"></div>
    </div>
    <div id="crosshair"></div>
    <div id="player-labels"></div>
    <div id="scoreboard">
        <h2>Tablica Wyników</h2>
        <table id="scoreboard-table">
            <thead>
                <tr><th>Gracz</th><th>Zabójstwa</th><th>Zgony</th></tr>
            </thead>
            <tbody></tbody>
        </table>
    </div>
    <!-- Nowy element dla statusu przeładowania -->
    <div id="reload-status">
        <span id="reload-text"></span>
        <div id="reload-progress-bar-container" style="display: none;"> <!-- Kontener paska ukryty, gdy jest tylko tekst -->
            <div id="reload-progress-bar"></div>
        </div>
    </div>
    <!-- Nowy element dla ekranu śmierci -->
    <div id="death-screen">
        <div id="death-message">ZGINĄŁEŚ!</div>
        <div id="killer-info">Zabił Cię: <span id="killer-name">Nieznany</span></div>
        <div id="respawn-timer">Odrodzenie za: 3s</div>
    </div>


    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // --- Zmienne globalne ---
        let scene, camera, renderer, controls;
        let playerVelocity = new THREE.Vector3();
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let canJump = true;

        let localPlayerId = null;
        let players = {}; // { id: { mesh, labelElement, healthBarElement, kills, deaths, name, health, weaponMesh? } }
        let localPlayerStats = { kills: 0, deaths: 0, health: 100, magazine: 0, ammo: 0 };
        let projectiles = {};
        let obstacles = [];

        // --- Zmienne dla broni FPV ---
        let weaponModel;
        let muzzleFlash;

        // --- Zmienne stanu lokalnego ---
        let isReloading = false;
        let reloadStartTime = 0;
        let isDead = false;
        let respawnCountdown = 0; // Licznik czasu do odrodzenia w sekundach
        let killerName = 'Nieznany'; // Kto zabił gracza

        // --- Stałe ---
        const clock = new THREE.Clock();
        const playerEyeLevel = 1.6;
        const playerHeight = 1.8;
        const playerRadius = 0.4;
        const playerSpeed = 5.0;
        const gravity = 18.0;
        const jumpVelocity = 7.5;
        const START_HEALTH = 100;
        const MAX_MAGAZINE = 30; // Maksymalna pojemność magazynka (klient też musi wiedzieć)
        const RELOAD_DURATION = 2000; // ms - czas przeładowania (klient też musi wiedzieć)
        const RESPAWN_TIME_SECONDS = 3; // s - czas odrodzenia

        // --- Elementy DOM ---
        let ws;
        const connectionStatusElement = document.getElementById('connection-status');
        const scoreboardElement = document.getElementById('scoreboard');
        const scoreboardTableBody = scoreboardElement.querySelector('#scoreboard-table tbody');
        const eventLogElement = document.getElementById('event-log'); // Przeniesiony do top-right-hud
        const healthHeartsElement = document.getElementById('health-hearts');
        const reloadStatusElement = document.getElementById('reload-status');
        const reloadTextElement = document.getElementById('reload-text');
        const reloadProgressBarContainer = document.getElementById('reload-progress-bar-container');
        const reloadProgressBar = document.getElementById('reload-progress-bar');
        const deathScreenElement = document.getElementById('death-screen');
        const killerNameElement = document.getElementById('killer-name');
        const respawnTimerElement = document.getElementById('respawn-timer');
        const ammoElement = document.getElementById('ammo'); // Referencja do elementu amunicji w HUD

        // --- Inicjalizacja ---
        init();

        // --- Funkcje ---

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 15, 70);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.y = playerEyeLevel;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            controls = new PointerLockControls(camera, document.body);
            scene.add(controls.getObject());
            controls.getObject().position.y = playerEyeLevel;

            document.addEventListener('click', () => {
                if (!controls.isLocked && !isDead) { // Nie blokuj, jeśli gracz nie żyje
                    controls.lock();
                }
            });
            controls.addEventListener('lock', () => console.log('Pointer locked'));
            controls.addEventListener('unlock', () => {
                console.log('Pointer unlocked');
                moveForward = moveBackward = moveLeft = moveRight = false;
            });

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
            dirLight.position.set(15, 20, 10);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            dirLight.shadow.camera.near = 0.5;
            dirLight.shadow.camera.far = 60;
            dirLight.shadow.camera.left = -25;
            dirLight.shadow.camera.right = 25;
            dirLight.shadow.camera.top = 25;
            dirLight.shadow.camera.bottom = -25;
            scene.add(dirLight);

            const groundGeometry = new THREE.PlaneGeometry(100, 100);
            const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x4a5d23, roughness: 0.9 });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            const boxGeometry = new THREE.BoxGeometry(1, 1, 1);
            const boxMaterial = new THREE.MeshStandardMaterial({ color: 0xA0522D, roughness: 0.7 });
            for (let i = 0; i < 15; ++i) {
                 const sizeX = Math.random() * 2 + 1;
                 const sizeY = Math.random() * 2 + 1;
                 const sizeZ = Math.random() * 2 + 1;
                 const box = new THREE.Mesh(boxGeometry.clone(), boxMaterial.clone()); // Klonuj, by móc skalować niezależnie
                 box.scale.set(sizeX, sizeY, sizeZ);
                 box.position.set(Math.random() * 50 - 25, sizeY / 2, Math.random() * 50 - 25);
                 box.castShadow = true;
                 box.receiveShadow = true;
                 scene.add(box);

                 box.geometry.computeBoundingBox();
                 box.userData.boundingBox = new THREE.Box3();
                 box.updateMatrixWorld(true);
                 box.userData.boundingBox.copy(box.geometry.boundingBox).applyMatrix4(box.matrixWorld);
                 obstacles.push(box);
            }

             weaponModel = createWeaponModel();
             camera.add(weaponModel);
             positionWeaponModel();

             muzzleFlash = new THREE.PointLight(0xffcc66, 0, 5, 1);
             muzzleFlash.position.set(0.1, -0.05, -0.5);
             weaponModel.add(muzzleFlash);

            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousedown', onMouseDown);
            window.addEventListener('resize', onWindowResize);

            // Inicjalizacja serc przy starcie (jako puste)
            updateHealthHearts();

            connectWebSocket();
            animate();
        }

        function createWeaponModel() {
             const weaponGroup = new THREE.Group();
             const gunMaterial = new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.6, roughness: 0.4 });
             const body = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.15, 0.6), gunMaterial);
             body.position.z = -0.2;
             weaponGroup.add(body);
             const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.03, 0.4, 16), gunMaterial);
             barrel.position.z = -0.6;
             barrel.rotation.x = Math.PI / 2;
             weaponGroup.add(barrel);
             const magazine = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.2, 0.15), gunMaterial);
             magazine.position.set(0, -0.15, -0.2);
             weaponGroup.add(magazine);
             const grip = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.2, 0.08), gunMaterial);
             grip.position.set(0, -0.08, 0.05);
             grip.rotation.x = -Math.PI / 10;
             weaponGroup.add(grip);
             weaponGroup.castShadow = true;
             weaponGroup.traverse(child => { if (child.isMesh) child.castShadow = true; });
             return weaponGroup;
         }

         function positionWeaponModel() {
             if (!weaponModel) return;
             weaponModel.position.set(0.25, -0.25, -0.7);
             weaponModel.rotation.set(0, -Math.PI / 128, 0);
         }

         // --- NOWA FUNKCJA: Dodaje prosty model broni do modelu gracza ---
         function addWeaponToPlayerModel(playerGroup) {
            const weaponMaterial = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.7 });
            // Prosta "broń" jako prostopadłościan
            const simpleWeapon = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 0.5), weaponMaterial);
            // Pozycjonowanie względem grupy gracza (metodą prób i błędów)
            simpleWeapon.position.set(playerRadius * 0.6, playerHeight * 0.6, 0.2); // Trochę z boku, na wysokości tułowia, lekko z przodu
            simpleWeapon.rotation.set(0, -Math.PI/6, 0); // Lekki obrót
            simpleWeapon.castShadow = true;
            playerGroup.add(simpleWeapon); // Dodaj do grupy gracza
            return simpleWeapon; // Zwróć referencję, jeśli potrzebna
        }


        function connectWebSocket() {
             const wsUrl = `ws://localhost:8080`; // Użyj hostname strony
             console.log(`Łączenie z ${wsUrl}...`);
             updateConnectionStatus('Łączenie...');
             ws = new WebSocket(wsUrl);

             ws.onopen = () => {
                 console.log("Połączono z serwerem WebSocket.");
                 updateConnectionStatus('Połączono');
             };

             ws.onmessage = (event) => {
                 try {
                     const message = JSON.parse(event.data);
                     handleServerMessage(message);
                 } catch (error) {
                     console.error("Błąd przetwarzania wiadomości od serwera:", error, "Otrzymano:", event.data);
                 }
             };

             ws.onerror = (error) => {
                 console.error("Błąd WebSocket:", error);
                 updateConnectionStatus('Błąd połączenia!');
                 updateHUD(0, 0); // Zeruj HUD amunicji
                 updateHealthHearts(); // Zeruj serca
                 resetLocalState(); // Resetuj stan lokalny przy błędzie
             };

             ws.onclose = () => {
                 console.log("Rozłączono z serwerem WebSocket.");
                 updateConnectionStatus('Rozłączono');
                 updateHUD(0, 0);
                 updateHealthHearts();
                 resetLocalState();

                 for (const id in players) removePlayer(id);
                 players = {};
                 for (const id in projectiles) removeProjectile(id);
                 projectiles = {};
                 updateScoreboard();
             };
         }

        function resetLocalState() {
            localPlayerId = null;
            localPlayerStats = { kills: 0, deaths: 0, health: 0, magazine: 0, ammo: 0 };
            isReloading = false;
            isDead = true; // Uznajemy za martwego po rozłączeniu
            hideReloadStatus();
            hideScoreboard();
            // Nie pokazuj ekranu śmierci przy zwykłym rozłączeniu
        }


        function updateConnectionStatus(status) {
            if (connectionStatusElement) {
                connectionStatusElement.textContent = status;
                connectionStatusElement.style.display = 'block';
                if (status === 'Połączono') {
                     connectionStatusElement.style.color = '#00ff00';
                     setTimeout(() => { if (connectionStatusElement.textContent === 'Połączono') connectionStatusElement.style.display = 'none';}, 3000);
                } else if (status === 'Rozłączono' || status.includes('Błąd')) {
                    connectionStatusElement.style.color = 'red';
                } else {
                    connectionStatusElement.style.color = '#ffcc00';
                }
            }
        }

        function handleServerMessage(message) {
            // console.log("Otrzymano:", message.type); // Debug
            switch (message.type) {
                case 'init':
                    localPlayerId = message.payload.id;
                    console.log(`Otrzymano ID: ${localPlayerId}`);
                    players = {};
                    projectiles = {}; // Wyczyść pociski przy init
                    isDead = false; // Przyjmij, że startujemy żywi
                    hideDeathScreen(); // Ukryj ekran śmierci na wszelki wypadek
                    for (const id in message.payload.players) {
                        const pData = message.payload.players[id];
                        if (id === localPlayerId) {
                            controls.getObject().position.set(pData.x, playerEyeLevel, pData.z);
                            playerVelocity.set(0,0,0);
                            localPlayerStats = { kills: pData.kills, deaths: pData.deaths, health: pData.health, magazine: pData.magazine, ammo: pData.ammo };
                            updateHUD(pData.magazine, pData.ammo);
                            updateHealthHearts(); // Zaktualizuj serca
                            checkReloadPrompt(); // Sprawdź komunikat o przeładowaniu
                        } else {
                            addOrUpdatePlayer(pData);
                        }
                    }
                     message.payload.projectiles?.forEach(pData => addOrUpdateProjectile(pData));
                    break;
                case 'player_joined':
                     addLogMessage(`${message.payload.name} dołączył do gry.`, 'join');
                     if (message.payload.id !== localPlayerId) {
                         addOrUpdatePlayer(message.payload);
                     }
                     // Zaktualizuj tablicę wyników, jeśli jest widoczna
                    if (scoreboardElement.style.display === 'block') {
                       updateScoreboard();
                    }
                    break;
                case 'player_left':
                     addLogMessage(`${message.payload.name || 'Gracz'} opuścił grę.`, 'leave');
                     if (message.payload.id !== localPlayerId) {
                         removePlayer(message.payload.id);
                     }
                      // Zaktualizuj tablicę wyników, jeśli jest widoczna
                     if (scoreboardElement.style.display === 'block') {
                        updateScoreboard();
                     }
                    break;
                case 'game_state':
                    let localPlayerDiedThisTick = false;
                    // Aktualizacja graczy
                    for (const id in message.payload.players) {
                        const pData = message.payload.players[id];
                        if (id === localPlayerId) {
                            // Sprawdź, czy gracz właśnie zginął
                            if (localPlayerStats.health > 0 && pData.health <= 0 && !isDead) {
                                localPlayerDiedThisTick = true;
                                console.log("Wykryto śmierć lokalnego gracza.");
                            }
                            // Zaktualizuj lokalne statystyki
                            localPlayerStats.kills = pData.kills;
                            localPlayerStats.deaths = pData.deaths;
                            localPlayerStats.health = pData.health;
                            localPlayerStats.magazine = pData.magazine;
                            localPlayerStats.ammo = pData.ammo;

                            updateHUD(pData.magazine, pData.ammo); // Aktualizuj amunicję
                            updateHealthHearts(); // Zaktualizuj serca
                            checkReloadPrompt(); // Sprawdź komunikat przeładowania

                            // Jeśli gracz żyje, upewnij się, że stan `isDead` jest poprawny
                             if (pData.health > 0 && isDead) {
                                isDead = false;
                                hideDeathScreen();
                             }

                        } else {
                            addOrUpdatePlayer(pData);
                        }
                    }
                     // Usuwanie pocisków
                     message.payload.removedProjectiles?.forEach(projId => removeProjectile(projId));
                     // Obsługa trafień
                     message.payload.hits?.forEach(hit => {
                         if (hit.targetId === localPlayerId) {
                             console.log(`Zostałeś trafiony przez ${hit.attackerName}! Zdrowie: ${hit.newHealth}`);
                             // Efekt wizualny trafienia (np. czerwony błysk) można dodać tutaj
                         }
                     });
                     // Obsługa zgonów
                     message.payload.deaths?.forEach(death => {
                         const victimName = death.victimName || 'Nieznany';
                         const attackerName = death.attackerName || 'Nieznany';
                          const attackerSpan = `<span class="attacker">${attackerName}</span>`;
                          const victimSpan = `<span class="victim">${victimName}</span>`;
                          let killMsg = (death.victimId === death.attackerId)
                              ? `${victimSpan} popełnił samobójstwo.`
                              : `${attackerSpan} pokonał ${victimSpan}.`;
                          addLogMessage(killMsg, 'kill');

                          // Sprawdź, czy to lokalny gracz zginął
                          if (death.victimId === localPlayerId && localPlayerDiedThisTick) {
                                killerName = attackerName; // Zapisz imię zabójcy
                                showDeathScreen(); // Pokaż ekran śmierci
                          }
                     });

                    if (scoreboardElement.style.display === 'block') {
                       updateScoreboard();
                    }
                    break;
                case 'projectile_created':
                    addOrUpdateProjectile(message.payload);
                    break;
                 case 'ammo_update': // Otrzymano po zakończeniu przeładowania lub strzale
                      if (localPlayerId) {
                          localPlayerStats.magazine = message.payload.magazine;
                          localPlayerStats.ammo = message.payload.ammo;
                          updateHUD(message.payload.magazine, message.payload.ammo);
                          if (isReloading) { // Jeśli otrzymano podczas przeładowania, oznacza to jego koniec
                            isReloading = false;
                            hideReloadStatus();
                          }
                          checkReloadPrompt(); // Sprawdź ponownie komunikat
                      }
                      break;
                 case 'player_respawned':
                     const respawnedData = message.payload;
                     if (respawnedData.id === localPlayerId) {
                         console.log("Zostałeś odrodzony!");
                         isDead = false; // Gracz znowu żyje
                         hideDeathScreen(); // Ukryj ekran śmierci
                         controls.getObject().position.set(respawnedData.x, playerEyeLevel, respawnedData.z);
                         playerVelocity.set(0, 0, 0);
                         localPlayerStats.health = respawnedData.health;
                         localPlayerStats.magazine = respawnedData.magazine;
                         localPlayerStats.ammo = respawnedData.ammo;
                         updateHUD(respawnedData.magazine, respawnedData.ammo);
                         updateHealthHearts();
                         checkReloadPrompt();
                         // Jeśli kursor był odblokowany po śmierci, można go zablokować ponownie
                         // if (!controls.isLocked) controls.lock();
                     } else {
                          if (players[respawnedData.id]) {
                              const player = players[respawnedData.id];
                              player.mesh.visible = true;
                              player.mesh.position.set(respawnedData.x, 0, respawnedData.z);
                              // Aktualizacja zdrowia/ammo przyjdzie w game_state
                          }
                     }
                     break;
            }
        }

         function addLogMessage(message, type = 'info') {
             if (!eventLogElement) return;
             const messageDiv = document.createElement('div');
             messageDiv.className = `log-message ${type}`;
             messageDiv.innerHTML = message;
             eventLogElement.appendChild(messageDiv);
             setTimeout(() => {
                 if (messageDiv.parentNode === eventLogElement) {
                      eventLogElement.removeChild(messageDiv);
                 }
             }, 5500);
              const maxMessages = 5;
              while (eventLogElement.children.length > maxMessages) {
                   if (eventLogElement.firstChild) {
                        eventLogElement.removeChild(eventLogElement.firstChild);
                   } else {
                        break;
                   }
              }
         }

        function createPlayerModel() {
             const playerGroup = new THREE.Group();
             const bodyMaterial = new THREE.MeshStandardMaterial({ color: Math.random() * 0xAAAAAA + 0x555555, roughness: 0.6 });
             const headMaterial = new THREE.MeshStandardMaterial({ color: 0xffdbac, roughness: 0.5 });
             const headRadius = 0.2;
             const torsoHeight = 0.7;
             const torsoWidth = 0.4;
             const limbRadius = 0.1;
             const armLength = 0.6;
             const legHeight = 0.8;

             const headMesh = new THREE.Mesh(new THREE.SphereGeometry(headRadius, 16, 12), headMaterial);
             headMesh.position.y = legHeight + torsoHeight - headRadius * 0.5;
             headMesh.castShadow = true;
             playerGroup.add(headMesh);

             const torsoMesh = new THREE.Mesh(new THREE.BoxGeometry(torsoWidth, torsoHeight, torsoWidth * 0.6), bodyMaterial);
             torsoMesh.position.y = legHeight + torsoHeight / 2;
             torsoMesh.castShadow = true;
             playerGroup.add(torsoMesh);

             const armGeometry = new THREE.BoxGeometry(limbRadius * 1.5, armLength, limbRadius * 1.5);
             const leftArmMesh = new THREE.Mesh(armGeometry, bodyMaterial);
             // Poprawiona pozycja ramion - lekko niżej
             leftArmMesh.position.set(-(torsoWidth / 2 + limbRadius * 0.75), legHeight + torsoHeight * 0.6, 0); // Y mniejsze niż poprzednio
             leftArmMesh.rotation.z = Math.PI / 8; // Nieco bardziej opuszczone
             leftArmMesh.castShadow = true;
             playerGroup.add(leftArmMesh);

             const rightArmMesh = leftArmMesh.clone();
             rightArmMesh.position.x *= -1;
             rightArmMesh.rotation.z *= -1;
             playerGroup.add(rightArmMesh);

             const legGeometry = new THREE.BoxGeometry(limbRadius * 1.8, legHeight, limbRadius * 1.8);
             const leftLegMesh = new THREE.Mesh(legGeometry, bodyMaterial);
             leftLegMesh.position.set(-(torsoWidth / 4), legHeight / 2, 0);
             leftLegMesh.castShadow = true;
             playerGroup.add(leftLegMesh);

             const rightLegMesh = leftLegMesh.clone();
             rightLegMesh.position.x *= -1;
             playerGroup.add(rightLegMesh);

             playerGroup.position.set(0, 0, 0);
             playerGroup.traverse(child => {
                   if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                   }
              });

              // Dodaj model broni do gracza
              const weapon = addWeaponToPlayerModel(playerGroup);
              playerGroup.userData.weaponMesh = weapon; // Zapisz referencję, jeśli potrzebna

             return playerGroup;
         }

        function addOrUpdatePlayer(playerData) {
            if (!playerData || !playerData.id) return;
            let player = players[playerData.id];

            if (!player) {
                 const playerModel = createPlayerModel();
                 playerModel.position.set(playerData.x, 0, playerData.z);
                 scene.add(playerModel);

                 const labelDiv = document.createElement('div');
                 labelDiv.className = 'player-label';
                 labelDiv.innerHTML = `
                    ${playerData.name || 'Nieznany'}
                    <div class="health-bar"><div class="health-bar-inner"></div></div>
                 `;
                 document.getElementById('player-labels').appendChild(labelDiv);
                 const healthBarInner = labelDiv.querySelector('.health-bar-inner');

                 players[playerData.id] = {
                    id: playerData.id, name: playerData.name, mesh: playerModel,
                    labelElement: labelDiv, healthBarElement: healthBarInner,
                    health: playerData.health, kills: playerData.kills, deaths: playerData.deaths,
                    weaponMesh: playerModel.userData.weaponMesh // Pobierz referencję broni
                 };
                 player = players[playerData.id];
                 console.log(`Dodano gracza: ${playerData.name} (${playerData.id})`);
            } else {
                 player.mesh.position.lerp(new THREE.Vector3(playerData.x, 0, playerData.z), 0.3);
                 player.mesh.rotation.y = THREE.MathUtils.lerp(player.mesh.rotation.y, playerData.yaw, 0.5);
                 player.health = playerData.health;
                 player.kills = playerData.kills;
                 player.deaths = playerData.deaths;
            }

             const isAlive = playerData.health > 0;
             player.mesh.visible = isAlive;
             player.labelElement.style.display = isAlive ? 'block' : 'none';
             // Ukryj/pokaż broń razem z graczem
             if (player.weaponMesh) {
                player.weaponMesh.visible = isAlive;
             }

             if (isAlive) {
                 updatePlayerLabel(player, playerData.health);
             }
        }

         function removePlayer(playerId) {
             const player = players[playerId];
             if (player) {
                 console.log(`Usuwanie gracza: ${player.name} (${playerId})`);
                 scene.remove(player.mesh);
                  player.mesh.traverse(child => {
                       if (child.geometry) child.geometry.dispose();
                       if (child.material) {
                           if (Array.isArray(child.material)) {
                               child.material.forEach(mat => mat.dispose());
                           } else {
                               child.material.dispose();
                           }
                       }
                  });
                 if (player.labelElement && player.labelElement.parentNode) {
                      player.labelElement.parentNode.removeChild(player.labelElement);
                 }
                 delete players[playerId];
             }
         }

         const LABEL_Y_OFFSET = playerHeight + 0.3;

         function updatePlayerLabel(player, health) {
            if (!player || !player.labelElement) return;
            const healthPerc = Math.max(0, Math.min(100, (health / START_HEALTH) * 100));
            if (player.healthBarElement) {
                player.healthBarElement.style.width = `${healthPerc}%`;
            }

            const mesh = player.mesh;
            const label = player.labelElement;
            const worldPosition = new THREE.Vector3();
            mesh.getWorldPosition(worldPosition);
            worldPosition.y += LABEL_Y_OFFSET;
            const screenPosition = worldPosition.project(camera);
            const isVisible = Math.abs(screenPosition.x) <= 1 && Math.abs(screenPosition.y) <= 1 && screenPosition.z > 0;

            if (isVisible && player.mesh.visible) {
                const x = (screenPosition.x * 0.5 + 0.5) * window.innerWidth;
                const y = (-screenPosition.y * 0.5 + 0.5) * window.innerHeight;
                label.style.left = `${x}px`;
                label.style.top = `${y}px`;
                label.style.display = 'block';
            } else {
                label.style.display = 'none';
            }
        }

        function addOrUpdateProjectile(projData) {
             if (!projData || !projData.id || projectiles[projData.id]) return;
             const projGeometry = new THREE.SphereGeometry(0.06, 6, 6);
             const projMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
             const mesh = new THREE.Mesh(projGeometry, projMaterial);
             mesh.position.set(projData.x, projData.y, projData.z);
             scene.add(mesh);
             projectiles[projData.id] = {
                id: projData.id, mesh: mesh, vx: projData.vx, vy: projData.vy, vz: projData.vz,
                spawnTime: Date.now()
             };
         }

         function removeProjectile(projId) {
             const proj = projectiles[projId];
             if (proj) {
                 scene.remove(proj.mesh);
                 proj.mesh.geometry.dispose();
                 proj.mesh.material.dispose();
                 delete projectiles[projId];
             }
         }

        // Zaktualizowana funkcja HUD - tylko amunicja
        function updateHUD(magazine, ammo) {
            if(ammoElement) {
                 ammoElement.textContent = `${magazine} / ${ammo}`;
            }
        }

        // --- NOWA FUNKCJA: Aktualizacja serc ---
        function updateHealthHearts() {
            if (!healthHeartsElement) return;
            healthHeartsElement.innerHTML = ''; // Wyczyść
            const currentHealth = localPlayerStats?.health ?? 0; // Pobierz zdrowie lub 0 jeśli brak
            const numFullHearts = Math.ceil(Math.max(0, currentHealth) / 10); // Ile serc ma być pełnych (min 0)

            for (let i = 0; i < 10; i++) {
                const heartDiv = document.createElement('div');
                heartDiv.classList.add('heart');
                if (i < numFullHearts) {
                    heartDiv.classList.add('heart-full');
                } else {
                    heartDiv.classList.add('heart-empty');
                }
                healthHeartsElement.appendChild(heartDiv);
            }
        }

        // --- NOWA FUNKCJA: Sprawdza, czy pokazać komunikat o przeładowaniu ---
        function checkReloadPrompt() {
            if (isReloading || isDead || !localPlayerId) { // Nie pokazuj, jeśli przeładowuje, martwy lub niepołączony
                hideReloadStatus(); // Ukryj na wszelki wypadek
                return;
            }

            if (localPlayerStats.magazine === 0 && localPlayerStats.ammo > 0) {
                showReloadPrompt(); // Pokaż tylko tekst
            } else {
                // Jeśli nie jest pusty magazynek, a nie przeładowuje, ukryj status
                if (!isReloading) {
                     hideReloadStatus();
                }
            }
        }

        // Pokazuje tylko tekst "Przeładuj (R)"
        function showReloadPrompt() {
            if (!reloadStatusElement) return;
            reloadTextElement.textContent = "Przeładuj (R)";
            reloadProgressBarContainer.style.display = 'none'; // Ukryj pasek
            reloadStatusElement.style.display = 'block';
        }

        // Pokazuje status "Przeładowanie..." z paskiem postępu
        function showReloadingStatus() {
            if (!reloadStatusElement) return;
            isReloading = true;
            reloadStartTime = Date.now();
            reloadTextElement.textContent = "Przeładowanie...";
            reloadProgressBar.style.width = '0%'; // Zresetuj pasek
            reloadProgressBarContainer.style.display = 'block'; // Pokaż pasek
            reloadStatusElement.style.display = 'block';
        }

        // Ukrywa cały element statusu przeładowania
        function hideReloadStatus() {
             if (reloadStatusElement) {
                 reloadStatusElement.style.display = 'none';
             }
        }

         // Aktualizuje pasek postępu przeładowania
        function updateReloadProgress(delta) {
            if (!isReloading || !reloadStatusElement || reloadStatusElement.style.display === 'none') return;

            const elapsedTime = Date.now() - reloadStartTime;
            const progress = Math.min(100, (elapsedTime / RELOAD_DURATION) * 100);
            reloadProgressBar.style.width = `${progress}%`;

            // Klient sam ukrywa pasek po czasie, ale serwer faktycznie kończy przeładowanie
            // if (elapsedTime >= RELOAD_DURATION) {
            //     isReloading = false; // Zostaw na true, aż serwer potwierdzi
            //     hideReloadStatus(); // Ukryj, gdy wizualny timer się skończy
            // }
        }

         // --- NOWA FUNKCJA: Pokazuje ekran śmierci ---
         function showDeathScreen() {
            if (!deathScreenElement) return;
            isDead = true; // Ustaw flagę śmierci
            killerNameElement.textContent = killerName; // Ustaw imię zabójcy
            respawnCountdown = RESPAWN_TIME_SECONDS; // Rozpocznij odliczanie
            respawnTimerElement.textContent = `Odrodzenie za: ${Math.ceil(respawnCountdown)}s`; // Pokaż czas
            deathScreenElement.style.display = 'flex'; // Pokaż ekran
            if (controls.isLocked) {
                controls.unlock(); // Odblokuj kursor
            }
            moveForward = moveBackward = moveLeft = moveRight = false; // Zatrzymaj ruch
            hideReloadStatus(); // Ukryj status przeładowania
         }

         // --- NOWA FUNKCJA: Ukrywa ekran śmierci ---
         function hideDeathScreen() {
             if (deathScreenElement) {
                 deathScreenElement.style.display = 'none';
             }
         }

        function onKeyDown(event) {
            // Ignoruj input jeśli gracz jest martwy (poza TAB dla scoreboardu i Escape)
            if (isDead && event.code !== 'Tab' && event.code !== 'Escape') return;
            // Zablokuj niektóre akcje, jeśli kursor nie jest zablokowany
            if (!controls.isLocked && !['Tab', 'Escape'].includes(event.code)) return;

            switch (event.code) {
                case 'KeyW': case 'ArrowUp': moveForward = true; break;
                case 'KeyA': case 'ArrowLeft': moveLeft = true; break;
                case 'KeyS': case 'ArrowDown': moveBackward = true; break;
                case 'KeyD': case 'ArrowRight': moveRight = true; break;
                case 'Space':
                    if (canJump && !isDead) { // Skok tylko gdy żywy
                        playerVelocity.y = jumpVelocity;
                        canJump = false;
                    }
                    break;
                case 'KeyR': // Przeładowanie
                    // Sprawdź warunki: połączony, żywy, nie przeładowuje, magazynek niepełny, jest amunicja zapasowa
                    if (ws && ws.readyState === WebSocket.OPEN && localPlayerId && !isDead && !isReloading &&
                        localPlayerStats.magazine < MAX_MAGAZINE && localPlayerStats.ammo > 0)
                    {
                        console.log("Wysyłanie żądania przeładowania...");
                        ws.send(JSON.stringify({ type: 'request_reload' }));
                        // Natychmiast pokaż status przeładowania po stronie klienta
                        showReloadingStatus();
                    }
                    break;
                case 'Tab':
                    event.preventDefault();
                    showScoreboard();
                    break;
            }
        }

        function onKeyUp(event) {
             // Nie trzeba sprawdzać `isDead` tutaj, bo puszczenie klawisza powinno zawsze resetować flagę ruchu
            switch (event.code) {
                case 'KeyW': case 'ArrowUp': moveForward = false; break;
                case 'KeyA': case 'ArrowLeft': moveLeft = false; break;
                case 'KeyS': case 'ArrowDown': moveBackward = false; break;
                case 'KeyD': case 'ArrowRight': moveRight = false; break;
                 case 'Tab':
                    hideScoreboard();
                    break;
            }
        }

        function onMouseDown(event) {
             if (controls.isLocked && event.button === 0 && !isDead && !isReloading) { // Lewy przycisk, gdy kursor zablokowany, gracz żyje i nie przeładowuje
                 shoot();
             }
        }

        function shoot() {
             if (!ws || ws.readyState !== WebSocket.OPEN || !localPlayerId || localPlayerStats.health <= 0 || localPlayerStats.magazine <= 0 || isReloading) {
                 if (localPlayerStats.magazine <= 0 && localPlayerStats.ammo > 0 && !isReloading && !isDead) {
                     console.log("Pusty magazynek - pokaż prompt!");
                     showReloadPrompt(); // Pokaż komunikat, jeśli magazynek pusty
                 }
                 return;
             }

             const direction = new THREE.Vector3();
             camera.getWorldDirection(direction);
             const startPos = new THREE.Vector3();
             camera.getWorldPosition(startPos);
             startPos.addScaledVector(direction, 0.6);

             ws.send(JSON.stringify({
                 type: 'shoot',
                 payload: {
                     direction: { x: direction.x, y: direction.y, z: direction.z },
                     startPos: { x: startPos.x, y: startPos.y, z: startPos.z }
                 }
             }));

             // Efekty lokalne
             if (localPlayerStats.magazine > 0) { // Dodatkowe zabezpieczenie
                 localPlayerStats.magazine--; // Zmniejsz lokalnie dla szybszego feedbacku
                 updateHUD(localPlayerStats.magazine, localPlayerStats.ammo);
                 checkReloadPrompt(); // Sprawdź, czy pokazać prompt po strzale
             }

             if (muzzleFlash) {
                 muzzleFlash.intensity = 2.0;
                 setTimeout(() => { muzzleFlash.intensity = 0; }, 60);
             }
             // TODO: Dźwięk, odrzut
        }

        function showScoreboard() {
             if (!localPlayerId) return;
             updateScoreboard();
             scoreboardElement.style.display = 'block';
         }

         function hideScoreboard() {
             scoreboardElement.style.display = 'none';
         }

         function updateScoreboard() {
             if (!scoreboardTableBody) return;
             scoreboardTableBody.innerHTML = '';

             const playerList = [];
             if (localPlayerId) {
                 // Użyj imienia z `players` obiektu, jeśli istnieje, inaczej "Ty"
                  const localName = players[localPlayerId]?.name || (localPlayerStats.name || "Ty");
                 playerList.push({
                       id: localPlayerId,
                       name: localName, // Użyj pobranego imienia
                       kills: localPlayerStats.kills,
                       deaths: localPlayerStats.deaths,
                       isLocal: true
                 });
             }
             for (const id in players) {
                 if (id !== localPlayerId) {
                     // Upewnij się, że gracz ma imię
                     const playerName = players[id].name || `Gracz_${id.substring(0,4)}`;
                     playerList.push({
                         id: id,
                         name: playerName,
                         kills: players[id].kills,
                         deaths: players[id].deaths,
                         isLocal: false
                     });
                 }
             }

             playerList.sort((a, b) => b.kills - a.kills);

             playerList.forEach(p => {
                 const row = scoreboardTableBody.insertRow();
                 if (p.isLocal) {
                     row.classList.add('local-player');
                 }
                 row.insertCell(0).textContent = p.name;
                 row.insertCell(1).textContent = p.kills;
                 row.insertCell(2).textContent = p.deaths;
             });
         }


        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        const moveDirection = new THREE.Vector3();
        const rightDirection = new THREE.Vector3();
        const forwardDirection = new THREE.Vector3();
        const playerCollider = new THREE.Box3();
        const obstacleCollider = new THREE.Box3();
        const collisionCheckVector = new THREE.Vector3();

        function animate() {
            requestAnimationFrame(animate);
            const delta = Math.min(clock.getDelta(), 0.1);

            // Aktualizacja pocisków
            for (const id in projectiles) {
                 const p = projectiles[id];
                 p.mesh.position.x += p.vx * delta;
                 p.mesh.position.y += p.vy * delta;
                 p.mesh.position.z += p.vz * delta;
                 if (Date.now() - p.spawnTime > 2500) {
                     removeProjectile(id);
                 }
            }

            // Aktualizacja statusu przeładowania (pasek postępu)
            if (isReloading) {
                updateReloadProgress(delta);
            }

            // Aktualizacja licznika odrodzenia
            if (isDead && respawnCountdown > 0) {
                respawnCountdown -= delta;
                respawnTimerElement.textContent = `Odrodzenie za: ${Math.max(0, Math.ceil(respawnCountdown))}s`;
                 // Animacja opadania kamery po śmierci
                 const playerObject = controls.getObject();
                 if (playerObject.position.y > 0.5) {
                     playerObject.position.y -= 2.0 * delta * Math.max(0.1, playerObject.position.y); // Szybsze opadanie na początku
                 }
            }

            // --- Aktualizacja ruchu i kolizji gracza lokalnego ---
             if (controls.isLocked === true && localPlayerId && !isDead) { // Ruszaj się tylko gdy żywy i kursor zablokowany
                const playerObject = controls.getObject();
                const oldPosition = playerObject.position.clone();

                playerVelocity.y -= gravity * delta;
                playerObject.position.y += playerVelocity.y * delta;

                if (playerObject.position.y < playerEyeLevel) {
                    playerVelocity.y = 0;
                    playerObject.position.y = playerEyeLevel;
                    canJump = true;
                }

                playerVelocity.x -= playerVelocity.x * 10.0 * delta;
                playerVelocity.z -= playerVelocity.z * 10.0 * delta;

                moveDirection.z = Number(moveForward) - Number(moveBackward);
                moveDirection.x = Number(moveRight) - Number(moveLeft);
                moveDirection.normalize();

                camera.getWorldDirection(forwardDirection);
                forwardDirection.y = 0;
                forwardDirection.normalize();
                rightDirection.crossVectors(camera.up, forwardDirection).normalize();

                const targetVelocityX = (forwardDirection.x * moveDirection.z + rightDirection.x * moveDirection.x) * playerSpeed;
                const targetVelocityZ = (forwardDirection.z * moveDirection.z + rightDirection.z * moveDirection.x) * playerSpeed;

                playerVelocity.x = THREE.MathUtils.lerp(playerVelocity.x, targetVelocityX, delta * 10.0);
                playerVelocity.z = THREE.MathUtils.lerp(playerVelocity.z, targetVelocityZ, delta * 10.0);

                const moveX = playerVelocity.x * delta;
                const moveZ = playerVelocity.z * delta;

                 let collisionX = false;
                 let collisionZ = false;

                 playerCollider.setFromCenterAndSize(
                     playerObject.position,
                     new THREE.Vector3(playerRadius * 2, playerHeight, playerRadius * 2)
                 );

                 obstacles.forEach(obstacle => {
                     const colliderX = playerCollider.clone().translate(new THREE.Vector3(moveX, 0, 0));
                     if (colliderX.intersectsBox(obstacle.userData.boundingBox)) {
                         collisionX = true;
                     }
                     const colliderZ = playerCollider.clone().translate(new THREE.Vector3(0, 0, moveZ));
                     if (colliderZ.intersectsBox(obstacle.userData.boundingBox)) {
                         collisionZ = true;
                     }
                 });

                  for (const pId in players) {
                      if (pId === localPlayerId || !players[pId].mesh.visible) continue;
                      const otherPlayerPos = players[pId].mesh.position;
                      // Prostsza kolizja gracz-gracz (większy margines)
                      const collisionRadiusSq = (playerRadius * 2.5) ** 2; // Zwiększ promień kolizji

                      collisionCheckVector.copy(playerObject.position).add(new THREE.Vector3(moveX, 0, 0));
                      if (collisionCheckVector.distanceToSquared(otherPlayerPos) < collisionRadiusSq) {
                          collisionX = true;
                      }
                       collisionCheckVector.copy(playerObject.position).add(new THREE.Vector3(0, 0, moveZ));
                       if (collisionCheckVector.distanceToSquared(otherPlayerPos) < collisionRadiusSq) {
                           collisionZ = true;
                       }
                  }

                 if (!collisionX) playerObject.position.x += moveX; else playerVelocity.x = 0;
                 if (!collisionZ) playerObject.position.z += moveZ; else playerVelocity.z = 0;

                 // Wysyłanie aktualizacji (można by optymalizować wysyłanie rzadziej)
                 if (ws && ws.readyState === WebSocket.OPEN) {
                     const controlObject = controls.getObject();
                     const yaw = controlObject.rotation.y;
                     let pitch = 0;
                     if (controlObject.children && controlObject.children.length > 0 && controlObject.children[0]) {
                        pitch = controlObject.children[0].rotation.x;
                     }

                     ws.send(JSON.stringify({
                         type: 'player_update',
                         payload: {
                             position: { x: playerObject.position.x, y: 1.0, z: playerObject.position.z },
                             rotation: { pitch: pitch, yaw: yaw }
                         }
                     }));
                 }
            }

             // Aktualizacja etykiet innych graczy
             for (const id in players) {
                if(id !== localPlayerId && players[id].mesh.visible){
                    updatePlayerLabel(players[id], players[id].health);
                }
             }

            renderer.render(scene, camera);
        }

    </script>
</body>
</html>