<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prototyp FPS WebGL v6 - Poprawki</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #222; color: white; font-family: sans-serif; }
        canvas { display: block; }
        #hud {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            color: white;
            font-size: 18px;
            z-index: 10;
        }
        #crosshair {
            position: absolute;
            left: 50%;
            top: 50%;
            width: 2px;
            height: 10px;
            background-color: lime;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 10;
        }
         #crosshair::before {
            content: '';
            position: absolute;
            left: -4px;
            top: 4px;
            width: 10px;
            height: 2px;
            background-color: lime;
         }

         .player-label {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.6);
            color: white;
            padding: 2px 5px;
            border-radius: 3px;
            font-size: 12px;
            white-space: nowrap;
            pointer-events: none;
            transform: translateX(-50%);
            text-align: center;
            z-index: 5;
        }
        /* Health bar below name is kept, but hearts are primary */
        .health-bar {
            height: 5px;
            background-color: #555; /* Darker background */
            margin-top: 2px;
            border-radius: 2px;
            overflow: hidden;
        }
         .health-bar-inner {
            height: 100%;
            background-color: lime;
            width: 100%;
            transition: width 0.2s ease-out; /* Smooth transition */
         }
         #scoreboard {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.75);
            border: 1px solid #555;
            border-radius: 8px;
            padding: 15px;
            color: white;
            font-size: 14px;
            min-width: 300px;
            z-index: 20;
            display: none;
         }
         #scoreboard table { width: 100%; border-collapse: collapse; }
         #scoreboard th, #scoreboard td { padding: 5px 8px; text-align: left; border-bottom: 1px solid #444; }
         #scoreboard th { font-weight: bold; }
         #scoreboard tr:last-child td { border-bottom: none; }
         #scoreboard .local-player td { font-weight: bold; color: #aaffaa; }

         #connection-status {
             position: absolute;
             top: 10px;
             left: 10px;
             color: #ffcc00;
             background-color: rgba(0,0,0,0.5);
             padding: 5px;
             border-radius: 3px;
             font-size: 12px;
             z-index: 10;
         }

         #top-right-hud {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            z-index: 16;
        }

         #health-hearts {
             display: flex;
             margin-bottom: 5px;
         }

         .heart {
             width: 20px;
             height: 18px;
             margin-left: 3px;
             background-size: contain;
             background-repeat: no-repeat;
             background-position: center;
             filter: drop-shadow(0 1px 1px rgba(0,0,0,0.5)); /* Subtle shadow */
         }

         .heart-full {
             background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="red"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/></svg>');
         }

         .heart-empty {
              background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="%23cccccc" stroke-width="2"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/></svg>'); /* Lighter grey stroke */
              opacity: 0.7;
         }

        #event-log {
             /* Positioned under hearts in top-right-hud */
             width: 250px;
             max-height: 150px;
             overflow: hidden;
             display: flex;
             flex-direction: column-reverse;
             z-index: 15;
         }
         .log-message {
             background-color: rgba(0, 0, 0, 0.6);
             color: #eee;
             padding: 4px 8px;
             margin-top: 4px;
             border-radius: 4px;
             font-size: 12px;
             white-space: nowrap;
             overflow: hidden;
             text-overflow: ellipsis;
             animation: fadeOut 5s forwards;
         }
         .log-message.join { color: #88ff88; }
         .log-message.leave { color: #ff8888; }
         .log-message.kill { color: #ffffff; }
         .log-message.kill .attacker { color: #ffdd88; font-weight: bold; }
         .log-message.kill .victim { color: #88ddff; font-weight: bold; }

         @keyframes fadeOut {
             0% { opacity: 1; }
             80% { opacity: 1; }
             100% { opacity: 0; }
         }


         #reload-status {
            position: absolute;
            top: 60%;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px 15px;
            border-radius: 5px;
            font-size: 16px;
            z-index: 12;
            display: none;
            text-align: center;
            min-width: 150px;
         }
         #reload-progress-bar-container {
            width: 100%;
            height: 8px;
            background-color: #555;
            border-radius: 4px;
            margin-top: 5px;
            overflow: hidden;
         }
          #reload-progress-bar {
             width: 0%;
             height: 100%;
             background-color: #4CAF50;
             border-radius: 4px;
             transition: width 0.1s linear;
          }

         #death-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(150, 0, 0, 0.7);
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            z-index: 50;
            display: none;
            text-align: center;
         }
         #death-message { font-size: 36px; margin-bottom: 10px; }
         #killer-info { font-size: 20px; margin-bottom: 20px; }
         #respawn-timer { font-size: 28px; font-weight: bold; }

    </style>
</head>
<body>
    <div id="connection-status">Connecting...</div>
    <div id="hud">
        Ammo: <span id="ammo">30 / 100</span>
    </div>
    <div id="top-right-hud">
         <div id="health-hearts"></div>
         <div id="event-log"></div>
    </div>
    <div id="crosshair"></div>
    <div id="player-labels"></div>
    <div id="scoreboard">
        <h2>Scoreboard</h2>
        <table id="scoreboard-table">
            <thead>
                <tr><th>Player</th><th>Kills</th><th>Deaths</th></tr>
            </thead>
            <tbody></tbody>
        </table>
    </div>
    <div id="reload-status">
        <span id="reload-text"></span>
        <div id="reload-progress-bar-container" style="display: none;">
            <div id="reload-progress-bar"></div>
        </div>
    </div>
    <div id="death-screen">
        <div id="death-message">YOU DIED!</div>
        <div id="killer-info">Killed by: <span id="killer-name">Unknown</span></div>
        <div id="respawn-timer">Respawn in: 3s</div>
    </div>


    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
         let CapsuleGeometry = THREE.CapsuleGeometry;
         if (!CapsuleGeometry) {
             console.warn("THREE.CapsuleGeometry not found, using BoxGeometry for limbs.");
             CapsuleGeometry = class FallbackCapsule extends THREE.BoxGeometry {
                 constructor(radius = 0.5, length = 1, capSegments = 4, radialSegments = 8) {
                     super(radius * 2, length + radius * 2, radius * 2);
                     console.warn("Using fallback BoxGeometry for Capsule.");
                 }
             };
         }


        // --- Global variables ---
        let scene, camera, renderer, controls;
        let playerVelocity = new THREE.Vector3();
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let canJump = true;

        let localPlayerId = null;
        let players = {}; // { id: { mesh, labelElement, healthBarElement, kills, deaths, name, health, weaponMesh? } }
        let localPlayerStats = { kills: 0, deaths: 0, health: 100, magazine: 0, ammo: 0 };
        let projectiles = {};
        let obstacles = [];

        // --- FPV Weapon variables ---
        let weaponModel;
        let muzzleFlash;

        // --- Local state variables ---
        let isReloading = false;
        let reloadStartTime = 0;
        let isDead = false;
        let respawnCountdown = 0;
        let killerName = 'Unknown';

        // --- Constants ---
        const clock = new THREE.Clock();
        const playerEyeLevel = 1.6;
        const playerHeight = 1.8;
        const playerRadius = 0.4;
        const playerSpeed = 5.0;
        const gravity = 18.0;
        const jumpVelocity = 7.5;
        const START_HEALTH = 100;
        const MAX_MAGAZINE = 30;
        const RELOAD_DURATION = 2000;
        const RESPAWN_TIME_SECONDS = 3;

        // --- DOM Elements ---
        let ws;
        const connectionStatusElement = document.getElementById('connection-status');
        const scoreboardElement = document.getElementById('scoreboard');
        const scoreboardTableBody = scoreboardElement.querySelector('#scoreboard-table tbody');
        const eventLogElement = document.getElementById('event-log');
        const healthHeartsElement = document.getElementById('health-hearts');
        const reloadStatusElement = document.getElementById('reload-status');
        const reloadTextElement = document.getElementById('reload-text');
        const reloadProgressBarContainer = document.getElementById('reload-progress-bar-container');
        const reloadProgressBar = document.getElementById('reload-progress-bar');
        const deathScreenElement = document.getElementById('death-screen');
        const killerNameElement = document.getElementById('killer-name');
        const respawnTimerElement = document.getElementById('respawn-timer');
        const ammoElement = document.getElementById('ammo');

        // --- Initialization ---
        init();

        // --- Functions ---

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 15, 70);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            controls = new PointerLockControls(camera, document.body);
            const playerObject = controls.getObject();
            playerObject.position.y = playerEyeLevel;
            scene.add(playerObject);

            document.addEventListener('click', () => { if (!controls.isLocked && !isDead) controls.lock(); });
            controls.addEventListener('lock', () => console.log('Pointer locked'));
            controls.addEventListener('unlock', () => { console.log('Pointer unlocked'); moveForward = moveBackward = moveLeft = moveRight = false; });

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7); scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 1.2); dirLight.position.set(15, 20, 10); dirLight.castShadow = true; dirLight.shadow.mapSize.width = 2048; dirLight.shadow.mapSize.height = 2048; dirLight.shadow.camera.near = 0.5; dirLight.shadow.camera.far = 60; dirLight.shadow.camera.left = -25; dirLight.shadow.camera.right = 25; dirLight.shadow.camera.top = 25; dirLight.shadow.camera.bottom = -25; scene.add(dirLight);

            const groundGeometry = new THREE.PlaneGeometry(100, 100); const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x4a5d23, roughness: 0.9 }); const ground = new THREE.Mesh(groundGeometry, groundMaterial); ground.rotation.x = -Math.PI / 2; ground.receiveShadow = true; scene.add(ground);

            const boxGeometry = new THREE.BoxGeometry(1, 1, 1); const boxMaterial = new THREE.MeshStandardMaterial({ color: 0xA0522D, roughness: 0.7 });
            for (let i = 0; i < 15; ++i) { const sizeX = Math.random() * 2 + 1; const sizeY = Math.random() * 2 + 1; const sizeZ = Math.random() * 2 + 1; const box = new THREE.Mesh(boxGeometry.clone(), boxMaterial.clone()); box.scale.set(sizeX, sizeY, sizeZ); box.position.set(Math.random() * 50 - 25, sizeY / 2, Math.random() * 50 - 25); box.castShadow = true; box.receiveShadow = true; scene.add(box); box.geometry.computeBoundingBox(); box.userData.boundingBox = new THREE.Box3(); box.updateMatrixWorld(true); box.userData.boundingBox.copy(box.geometry.boundingBox).applyMatrix4(box.matrixWorld); obstacles.push(box); }

            weaponModel = createWeaponModel(); camera.add(weaponModel); positionWeaponModel();
            muzzleFlash = new THREE.PointLight(0xffcc66, 0, 5, 1); muzzleFlash.position.set(0.1, -0.05, -0.5); weaponModel.add(muzzleFlash);

            document.addEventListener('keydown', onKeyDown); document.addEventListener('keyup', onKeyUp); document.addEventListener('mousedown', onMouseDown); window.addEventListener('resize', onWindowResize);

            updateHealthHearts();
            connectWebSocket();
            animate();
        }

        function createWeaponModel() {
            const weaponGroup = new THREE.Group(); const gunMaterial = new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.6, roughness: 0.4 });
            const body = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.15, 0.6), gunMaterial); body.position.z = -0.2; weaponGroup.add(body);
            const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.03, 0.4, 16), gunMaterial); barrel.position.z = -0.6; barrel.rotation.x = Math.PI / 2; weaponGroup.add(barrel);
            const magazine = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.2, 0.15), gunMaterial); magazine.position.set(0, -0.15, -0.2); weaponGroup.add(magazine);
            const grip = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.2, 0.08), gunMaterial); grip.position.set(0, -0.08, 0.05); grip.rotation.x = -Math.PI / 10; weaponGroup.add(grip);
            weaponGroup.castShadow = true; weaponGroup.traverse(child => { if (child.isMesh) child.castShadow = true; }); return weaponGroup;
        }

        function positionWeaponModel() { if (!weaponModel) return; weaponModel.position.set(0.25, -0.25, -0.7); weaponModel.rotation.set(0, -Math.PI / 128, 0); }

        function createPlayerModel() {
            const playerGroup = new THREE.Group();

            // --- Materials ---
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: Math.random() * 0x888888 + 0x444444, roughness: 0.7, metalness: 0.1 });
            const headMaterial = new THREE.MeshStandardMaterial({ color: 0xffdbac, roughness: 0.5 });
            const gearMaterial = new THREE.MeshStandardMaterial({ color: 0x556B2F, roughness: 0.8 });
            const helmetMaterial = new THREE.MeshStandardMaterial({ color: 0x404040, roughness: 0.6, metalness: 0.2 });
            const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0x111111 });
            const mouthMaterial = new THREE.MeshBasicMaterial({ color: 0x880000 });
            const weapon3PMaterial = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.7 });

            // --- Dimensions ---
            const headRadius = 0.2; const torsoHeight = 0.65; const torsoWidth = 0.45; const torsoDepth = 0.25;
            const limbRadius = 0.09; const armLength = 0.55; const legHeight = 0.7;
            const footDepth = 0.15; const footWidth = 0.12; const footLength = 0.25;

            // --- Vertical Positioning Calculations ---
            const footCenterY = footDepth / 2; const legBaseY = footCenterY + footDepth / 2 + limbRadius; const legCenterY = legBaseY + legHeight / 2;
            const torsoBaseY = legBaseY + legHeight + limbRadius; const torsoCenterY = torsoBaseY + torsoHeight / 2; const headCenterY = torsoBaseY + torsoHeight + headRadius * 0.9;

            // --- Feet, Legs, Torso, Head, Face Features ---
            const footGeometry = new THREE.BoxGeometry(footWidth, footDepth, footLength);
            const leftFootMesh = new THREE.Mesh(footGeometry, gearMaterial); leftFootMesh.position.set(-(torsoWidth / 4), footCenterY, footLength * 0.3); leftFootMesh.castShadow = true; playerGroup.add(leftFootMesh);
            const rightFootMesh = new THREE.Mesh(footGeometry, gearMaterial); rightFootMesh.position.set(torsoWidth / 4, footCenterY, footLength * 0.3); rightFootMesh.castShadow = true; playerGroup.add(rightFootMesh);

            const legGeometry = CapsuleGeometry ? new CapsuleGeometry(limbRadius, legHeight, 8, 16) : new THREE.BoxGeometry(limbRadius*2, legHeight+limbRadius*2, limbRadius*2);
            const leftLegMesh = new THREE.Mesh(legGeometry, bodyMaterial); leftLegMesh.position.set(-(torsoWidth / 4), legCenterY, 0); leftLegMesh.castShadow = true; playerGroup.add(leftLegMesh);
            const rightLegMesh = new THREE.Mesh(legGeometry, bodyMaterial); rightLegMesh.position.set(torsoWidth / 4, legCenterY, 0); rightLegMesh.castShadow = true; playerGroup.add(rightLegMesh);

            const torsoGeometry = new THREE.BoxGeometry(torsoWidth, torsoHeight, torsoDepth); const torsoMesh = new THREE.Mesh(torsoGeometry, bodyMaterial); torsoMesh.position.y = torsoCenterY; torsoMesh.castShadow = true; playerGroup.add(torsoMesh);
            const headGeometry = new THREE.SphereGeometry(headRadius, 20, 16); const headMesh = new THREE.Mesh(headGeometry, headMaterial); headMesh.position.y = headCenterY; headMesh.castShadow = true; playerGroup.add(headMesh);

            const eyeRadius = 0.03; const eyeYOffset = headRadius * 0.2; const eyeZOffset = headRadius * 0.85; const eyeXOffset = headRadius * 0.4;
            const leftEye = new THREE.Mesh(new THREE.SphereGeometry(eyeRadius, 8, 8), eyeMaterial); leftEye.position.set(-eyeXOffset, headCenterY + eyeYOffset, eyeZOffset); playerGroup.add(leftEye);
            const rightEye = new THREE.Mesh(new THREE.SphereGeometry(eyeRadius, 8, 8), eyeMaterial); rightEye.position.set(eyeXOffset, headCenterY + eyeYOffset, eyeZOffset); playerGroup.add(rightEye);
            const noseRadius = 0.04; const noseMesh = new THREE.Mesh(new THREE.SphereGeometry(noseRadius, 6, 6), headMaterial); noseMesh.position.set(0, headCenterY - headRadius * 0.1, headRadius * 0.8); playerGroup.add(noseMesh);
            const mouthGeom = new THREE.TorusGeometry(0.06, 0.015, 8, 12, Math.PI); const mouthMesh = new THREE.Mesh(mouthGeom, mouthMaterial); mouthMesh.position.set(0, headCenterY - headRadius * 0.4, headRadius * 0.75); mouthMesh.rotation.z = Math.PI; playerGroup.add(mouthMesh);

            // --- Arms Repositioned and Rotated to Hold Weapon ---
            const armGeometry = CapsuleGeometry ? new CapsuleGeometry(limbRadius, armLength, 8, 16) : new THREE.BoxGeometry(limbRadius*2, armLength+limbRadius*2, limbRadius*2);
            const armCenterY = torsoCenterY + torsoHeight * 0.3; // Base Y position for arms
            const armShoulderOffset = torsoWidth / 2 + limbRadius * 0.5; // Horizontal distance from center
            const armForwardOffset = torsoDepth / 2 + limbRadius * 0.5; // Forward distance from torso center

            // Left Arm
            const leftArmMesh = new THREE.Mesh(armGeometry, bodyMaterial);
            leftArmMesh.castShadow = true;
            leftArmMesh.position.set(-armShoulderOffset, armCenterY - 0.1, armForwardOffset); // Lowered slightly, moved forward
            leftArmMesh.rotation.set(Math.PI * 0.35, -Math.PI * 0.1, -Math.PI * 0.1); // Rotated more forward, slightly inward and down
            playerGroup.add(leftArmMesh);

            // Right Arm
            const rightArmMesh = new THREE.Mesh(armGeometry, bodyMaterial);
            rightArmMesh.castShadow = true;
            rightArmMesh.position.set(armShoulderOffset, armCenterY - 0.1, armForwardOffset); // Lowered slightly, moved forward
            rightArmMesh.rotation.set(Math.PI * 0.35, Math.PI * 0.1, Math.PI * 0.1); // Rotated more forward, slightly inward and down
            playerGroup.add(rightArmMesh);


            // --- Gear ---
            const helmetRadius = headRadius * 1.15; const helmetGeometry = new THREE.SphereGeometry(helmetRadius, 16, 12, 0, Math.PI * 2, 0, Math.PI * 0.7); const helmetMesh = new THREE.Mesh(helmetGeometry, helmetMaterial); helmetMesh.position.y = headCenterY + 0.02; helmetMesh.rotation.x = -0.1; helmetMesh.castShadow = true; playerGroup.add(helmetMesh);
            const vestGeometry = new THREE.BoxGeometry(torsoWidth * 1.1, torsoHeight * 0.9, torsoDepth * 1.2); const vestMesh = new THREE.Mesh(vestGeometry, gearMaterial); vestMesh.position.y = torsoCenterY; vestMesh.castShadow = true; playerGroup.add(vestMesh);
            const backpackGeometry = new THREE.BoxGeometry(torsoWidth * 0.7, torsoHeight * 0.6, torsoDepth * 0.8); const backpackMesh = new THREE.Mesh(backpackGeometry, gearMaterial); backpackMesh.position.set(0, torsoCenterY - torsoHeight*0.1, -(torsoDepth / 2 + torsoDepth * 0.4 / 2)); backpackMesh.castShadow = true; playerGroup.add(backpackMesh);

            // --- *** Add Visible 3rd Person Weapon - Repositioned *** ---
            const weapon3PGeometry = new THREE.BoxGeometry(0.1, 0.12, 0.75); // Slightly longer rifle shape
            const weapon3PMesh = new THREE.Mesh(weapon3PGeometry, weapon3PMaterial);

            // *** POPRAWKA: Dostosowanie pozycji i rotacji broni 3P ***
            // Pozycjonujemy broń względem *przybliżonej* pozycji dłoni wynikającej z ułożenia ramion
            const weaponY = armCenterY - 0.18; // Nieco niżej, aby pasowało do uchwytu
            const weaponZ = armForwardOffset + armLength * 0.35; // Bardziej do przodu, bliżej końca ramion
            weapon3PMesh.position.set(0, weaponY, weaponZ); // Pozycja w przestrzeni gracza
            weapon3PMesh.rotation.set(Math.PI * 0.4, 0, 0); // Kąt podobny do ramion (może wymagać dalszej korekty)

            weapon3PMesh.castShadow = true;
            playerGroup.add(weapon3PMesh);
            playerGroup.userData.weaponMesh = weapon3PMesh; // Store reference

            // --- Final Group Setup ---
            playerGroup.position.set(0, 0, 0); // Model base at (0,0,0) relative to player group anchor
            playerGroup.traverse(child => { if (child.isMesh) { child.castShadow = true; child.receiveShadow = true; }});

            return playerGroup;
        }

        function connectWebSocket() { const wsUrl = `ws://localhost:8080`; console.log(`Connecting to ${wsUrl}...`); updateConnectionStatus('Connecting...'); ws = new WebSocket(wsUrl); ws.onopen = () => { console.log("Connected to WebSocket server."); updateConnectionStatus('Connected'); }; ws.onmessage = (event) => { try { const message = JSON.parse(event.data); handleServerMessage(message); } catch (error) { console.error("Error processing server message:", error, "Received:", event.data); } }; ws.onerror = (error) => { console.error("WebSocket Error:", error); updateConnectionStatus('Connection Error!'); updateHUD(0, 0); updateHealthHearts(); resetLocalState(); }; ws.onclose = () => { console.log("Disconnected from WebSocket server."); updateConnectionStatus('Disconnected'); updateHUD(0, 0); updateHealthHearts(); resetLocalState(); for (const id in players) removePlayer(id); players = {}; for (const id in projectiles) removeProjectile(id); projectiles = {}; updateScoreboard(); }; }
        function resetLocalState() { localPlayerId = null; localPlayerStats = { kills: 0, deaths: 0, health: 0, magazine: 0, ammo: 0 }; isReloading = false; isDead = true; // Assume dead on reset
            hideReloadStatus(); hideScoreboard(); hideDeathScreen(); if (controls.isLocked) controls.unlock(); }
        function updateConnectionStatus(status) { if (!connectionStatusElement) return; connectionStatusElement.textContent = status; connectionStatusElement.style.display = 'block'; if (status === 'Connected') { connectionStatusElement.style.color = '#00ff00'; setTimeout(() => { if (connectionStatusElement.textContent === 'Connected') connectionStatusElement.style.display = 'none'; }, 3000); } else if (status === 'Disconnected' || status.includes('Error')) { connectionStatusElement.style.color = 'red'; } else { connectionStatusElement.style.color = '#ffcc00'; } }

        function handleServerMessage(message) {
            switch (message.type) {
                case 'init':
                    localPlayerId = message.payload.id;
                    console.log(`Received ID: ${localPlayerId}`);
                    // Clear existing players and projectiles on initialization
                    for (const id in players) removePlayer(id);
                    players = {};
                    for (const id in projectiles) removeProjectile(id);
                    projectiles = {};
                    isDead = false; // Assume alive on init
                    hideDeathScreen();
                    // Populate initial game state
                    for (const id in message.payload.players) {
                        const pData = message.payload.players[id];
                        if (id === localPlayerId) {
                            // Set local player position and state
                            controls.getObject().position.set(pData.x, pData.y, pData.z);
                            playerVelocity.set(0, 0, 0);
                            localPlayerStats = { name: pData.name, kills: pData.kills, deaths: pData.deaths, health: pData.health, magazine: pData.magazine, ammo: pData.ammo };
                            updateHUD(pData.magazine, pData.ammo);
                            updateHealthHearts();
                            checkReloadPrompt();
                            if (pData.health <= 0) { // Check if spawned dead (unlikely but possible)
                                showDeathScreen();
                                killerName = 'Unknown'; // Or get from server if available
                            }
                        } else {
                            addOrUpdatePlayer(pData);
                        }
                    }
                    message.payload.projectiles?.forEach(pData => addOrUpdateProjectile(pData));
                    updateScoreboard();
                    break;
                case 'player_joined':
                    addLogMessage(`${message.payload.name} joined the game.`, 'join');
                    if (message.payload.id !== localPlayerId) {
                        addOrUpdatePlayer(message.payload);
                    }
                    if (scoreboardElement.style.display === 'block') updateScoreboard();
                    break;
                case 'player_left':
                    addLogMessage(`${message.payload.name || 'Player'} left the game.`, 'leave');
                    if (message.payload.id !== localPlayerId) {
                        removePlayer(message.payload.id);
                    }
                    if (scoreboardElement.style.display === 'block') updateScoreboard();
                    break;
                case 'game_state':
                    let localPlayerDiedThisTick = false;
                    // Update all players based on server state
                    for (const id in message.payload.players) {
                        const pData = message.payload.players[id];
                        if (id === localPlayerId) {
                            // Check if died this tick
                            if (localPlayerStats.health > 0 && pData.health <= 0 && !isDead) {
                                localPlayerDiedThisTick = true;
                            }
                            // Update local player stats
                            localPlayerStats = { ...localPlayerStats, ...pData };
                            updateHUD(pData.magazine, pData.ammo);
                            updateHealthHearts();
                            checkReloadPrompt();
                            // Handle respawn initiated by server implicitly through health > 0
                            if (pData.health > 0 && isDead) {
                                isDead = false;
                                hideDeathScreen();
                                // Position might also be updated here if server sends it
                                controls.getObject().position.set(pData.x, pData.y, pData.z);
                                playerVelocity.set(0,0,0); // Reset velocity on respawn/state update
                            }
                        } else {
                            addOrUpdatePlayer(pData);
                        }
                    }
                    // Remove projectiles that expired or hit something
                    message.payload.removedProjectiles?.forEach(projId => removeProjectile(projId));
                    // Handle hit feedback (visual/audio could be added here)
                    message.payload.hits?.forEach(hit => {
                        if (hit.targetId === localPlayerId) {
                            console.log(`You were hit by ${hit.attackerName}! Health: ${hit.newHealth}`);
                            // TODO: Add visual hit indicator (e.g., red flash)
                        }
                        // TODO: Add hit sound effect for hits on others?
                    });
                    // Handle death events and log messages
                    message.payload.deaths?.forEach(death => {
                        const victimName = death.victimName || 'Unknown';
                        const attackerName = death.attackerName || 'Unknown';
                        const attackerSpan = `<span class="attacker">${attackerName}</span>`;
                        const victimSpan = `<span class="victim">${victimName}</span>`;
                        let killMsg = (death.victimId === death.attackerId)
                            ? `${victimSpan} committed suicide.`
                            : `${attackerSpan} defeated ${victimSpan}.`;
                        addLogMessage(killMsg, 'kill');
                        // Show death screen if local player died *this tick*
                        if (death.victimId === localPlayerId && localPlayerDiedThisTick) {
                            killerName = attackerName;
                            showDeathScreen();
                        }
                    });
                    // Update scoreboard if it's visible
                    if (scoreboardElement.style.display === 'block') updateScoreboard();
                    break;
                case 'projectile_created':
                    addOrUpdateProjectile(message.payload);
                    break;
                case 'ammo_update':
                    if (localPlayerId) {
                        localPlayerStats.magazine = message.payload.magazine;
                        localPlayerStats.ammo = message.payload.ammo;
                        updateHUD(message.payload.magazine, message.payload.ammo);
                        // If reloading finished (indicated by server sending update), hide status
                        if (isReloading) {
                            isReloading = false;
                            hideReloadStatus();
                        }
                        checkReloadPrompt(); // Check if prompt needed after update
                    }
                    break;
                case 'player_respawned':
                    const respawnedData = message.payload;
                    if (respawnedData.id === localPlayerId) {
                        console.log("You have respawned!");
                        isDead = false;
                        hideDeathScreen();
                        controls.getObject().position.set(respawnedData.x, respawnedData.y, respawnedData.z);
                        playerVelocity.set(0, 0, 0); // Reset velocity
                        localPlayerStats.health = respawnedData.health;
                        localPlayerStats.magazine = respawnedData.magazine;
                        localPlayerStats.ammo = respawnedData.ammo;
                        updateHUD(respawnedData.magazine, respawnedData.ammo);
                        updateHealthHearts();
                        checkReloadPrompt();
                    } else {
                        // Update other player's state on their respawn
                        if (players[respawnedData.id]) {
                            const player = players[respawnedData.id];
                            player.mesh.visible = true;
                            // Set position directly, maybe lerp later if needed
                            player.mesh.position.set(respawnedData.x, respawnedData.y - playerEyeLevel, respawnedData.z);
                            player.health = respawnedData.health;
                            // Update label and health bar
                            if (player.labelElement) player.labelElement.style.display = 'block';
                            updatePlayerLabel(player, player.health);
                             // Make weapon visible again
                            if(player.weaponMesh) player.weaponMesh.visible = true;
                        } else {
                            // If player wasn't known, add them (unlikely case for respawn)
                            addOrUpdatePlayer(respawnedData);
                        }
                    }
                     // Update scoreboard if visible
                    if (scoreboardElement.style.display === 'block') updateScoreboard();
                    break;
            }
        }

        function addLogMessage(message, type = 'info') {
            if (!eventLogElement) return;
            const messageDiv = document.createElement('div');
            messageDiv.className = `log-message ${type}`;
            messageDiv.innerHTML = message; // Use innerHTML to parse spans for kill messages
            eventLogElement.appendChild(messageDiv);

            // Remove the message after animation finishes (plus a buffer)
            setTimeout(() => {
                if (messageDiv.parentNode === eventLogElement) {
                    eventLogElement.removeChild(messageDiv);
                }
            }, 5500); // Match animation duration + buffer

            // Limit the number of messages displayed
            const maxMessages = 5;
            while (eventLogElement.children.length > maxMessages) {
                if (eventLogElement.firstChild) {
                    eventLogElement.removeChild(eventLogElement.firstChild);
                } else {
                    break; // Safety break
                }
            }
        }

        function addOrUpdatePlayer(playerData) {
            if (!playerData || !playerData.id) return;
            let player = players[playerData.id];
            const meshY = playerData.y - playerEyeLevel; // Calculate target feet Y from server eye Y

            if (!player) {
                // Create new player model and label
                const playerModel = createPlayerModel();
                playerModel.position.set(playerData.x, meshY, playerData.z); // Use calculated mesh Y
                scene.add(playerModel);
                const labelDiv = document.createElement('div');
                labelDiv.className = 'player-label';
                // Set initial content
                labelDiv.innerHTML = `${playerData.name || 'Unknown'} <div class="health-bar"><div class="health-bar-inner"></div></div>`;
                document.getElementById('player-labels').appendChild(labelDiv);
                const healthBarInner = labelDiv.querySelector('.health-bar-inner');

                // Store player data
                players[playerData.id] = {
                    id: playerData.id,
                    name: playerData.name,
                    mesh: playerModel,
                    labelElement: labelDiv,
                    healthBarElement: healthBarInner,
                    health: playerData.health,
                    kills: playerData.kills,
                    deaths: playerData.deaths,
                    weaponMesh: playerModel.userData.weaponMesh // Store ref to 3P weapon
                };
                player = players[playerData.id];
                console.log(`Added player: ${playerData.name} (${playerData.id})`);
            } else {
                // Update existing player position with interpolation (lerp)
                player.mesh.position.x = THREE.MathUtils.lerp(player.mesh.position.x, playerData.x, 0.3);
                player.mesh.position.y = THREE.MathUtils.lerp(player.mesh.position.y, meshY, 0.3); // Lerp Y
                player.mesh.position.z = THREE.MathUtils.lerp(player.mesh.position.z, playerData.z, 0.3);

                // *** POPRAWKA: Lerp rotation with Math.PI offset and wrap-around handling ***
                const targetYaw = playerData.yaw + Math.PI;
                const currentYaw = player.mesh.rotation.y;
                // Calculate the shortest angle difference
                let angleDifference = targetYaw - currentYaw;
                while (angleDifference < -Math.PI) angleDifference += Math.PI * 2;
                while (angleDifference > Math.PI) angleDifference -= Math.PI * 2;
                // Apply lerp to the difference
                player.mesh.rotation.y = currentYaw + angleDifference * 0.5; // Adjust lerp factor (0.5) as needed

                // Update other stats
                player.health = playerData.health;
                player.kills = playerData.kills;
                player.deaths = playerData.deaths;
                // Update name if it changes (optional)
                if (player.name !== playerData.name && player.labelElement) {
                     player.name = playerData.name;
                     player.labelElement.firstChild.textContent = `${player.name || 'Unknown'} `; // Update name part of label
                }
            }
            // Update visibility based on health
            const isAlive = playerData.health > 0;
            player.mesh.visible = isAlive;
            player.labelElement.style.display = isAlive ? 'block' : 'none';
            // Ensure 3P Weapon visibility matches player visibility
            if (player.weaponMesh) {
                player.weaponMesh.visible = isAlive;
            }
            // Update health bar and position if alive
            if (isAlive) {
                updatePlayerLabel(player, playerData.health);
            }
        }

        function removePlayer(playerId) {
             const player = players[playerId];
             if (player) {
                 console.log(`Removing player: ${player.name} (${playerId})`);
                 // Remove mesh from scene
                 scene.remove(player.mesh);
                 // Dispose geometry and materials to free memory
                 player.mesh.traverse(child => {
                     if (child.geometry) child.geometry.dispose();
                     if (child.material) {
                         if (Array.isArray(child.material)) {
                             child.material.forEach(mat => mat.dispose());
                         } else {
                             child.material.dispose();
                         }
                     }
                 });
                 // Remove label from DOM
                 if (player.labelElement && player.labelElement.parentNode) {
                     player.labelElement.parentNode.removeChild(player.labelElement);
                 }
                 // Delete player data
                 delete players[playerId];
             }
         }

        const LABEL_Y_OFFSET = playerHeight + 0.4; // Adjust as needed for label height above model
        function updatePlayerLabel(player, health) {
            if (!player || !player.labelElement || !player.mesh) return;

            // Update health bar width
            const healthPerc = Math.max(0, Math.min(100, (health / START_HEALTH) * 100));
            if (player.healthBarElement) {
                player.healthBarElement.style.width = `${healthPerc}%`;
            }

            const mesh = player.mesh;
            const label = player.labelElement;

            // Project world position to screen position
            const worldPosition = new THREE.Vector3();
            // Get world position of the mesh and add offset for label height
            mesh.getWorldPosition(worldPosition);
            worldPosition.y += LABEL_Y_OFFSET;

            const screenPosition = worldPosition.project(camera);

            // Check if label is within screen bounds and in front of camera
            const isVisible = Math.abs(screenPosition.x) <= 1 &&
                              Math.abs(screenPosition.y) <= 1 &&
                              screenPosition.z > 0;

            if (isVisible && player.mesh.visible) { // Only show if player mesh is visible
                // Convert normalized screen coordinates to pixel coordinates
                const x = (screenPosition.x * 0.5 + 0.5) * window.innerWidth;
                const y = (-screenPosition.y * 0.5 + 0.5) * window.innerHeight; // Y is inverted

                // Set label position and display
                label.style.left = `${x}px`;
                label.style.top = `${y}px`;
                label.style.display = 'block';
            } else {
                // Hide label if off-screen or behind camera
                label.style.display = 'none';
            }
        }

        function addOrUpdateProjectile(projData) {
            // Only add if it doesn't exist already
            if (!projData || !projData.id || projectiles[projData.id]) return;

            const projGeometry = new THREE.SphereGeometry(0.06, 6, 6);
            const projMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 }); // Bright yellow
            const mesh = new THREE.Mesh(projGeometry, projMaterial);
            mesh.position.set(projData.x, projData.y, projData.z);
            scene.add(mesh);

            projectiles[projData.id] = {
                id: projData.id,
                mesh: mesh,
                vx: projData.vx,
                vy: projData.vy,
                vz: projData.vz,
                spawnTime: Date.now() // Store spawn time for client-side lifetime check if needed
            };
        }

        function removeProjectile(projId) {
            const proj = projectiles[projId];
            if (proj) {
                scene.remove(proj.mesh);
                // Dispose geometry and material
                if (proj.mesh.geometry) proj.mesh.geometry.dispose();
                if (proj.mesh.material) proj.mesh.material.dispose();
                delete projectiles[projId];
            }
        }

        function updateHUD(magazine, ammo) {
            if (ammoElement) {
                ammoElement.textContent = `${magazine} / ${ammo}`;
            }
        }

        function updateHealthHearts() {
            if (!healthHeartsElement) return;
            healthHeartsElement.innerHTML = ''; // Clear existing hearts
            const currentHealth = localPlayerStats?.health ?? 0;
             // Calculate number of full hearts (1 heart = 10 health)
            const numFullHearts = Math.ceil(Math.max(0, currentHealth) / (START_HEALTH / 10)); // Use START_HEALTH for scaling
            const totalHearts = 10; // Always show 10 total slots

            for (let i = 0; i < totalHearts; i++) {
                const heartDiv = document.createElement('div');
                heartDiv.classList.add('heart');
                heartDiv.classList.add(i < numFullHearts ? 'heart-full' : 'heart-empty');
                healthHeartsElement.appendChild(heartDiv);
            }
        }

        function checkReloadPrompt() {
            // Don't show if reloading, dead, or not connected
            if (isReloading || isDead || !localPlayerId) {
                hideReloadStatus(); // Ensure it's hidden
                return;
            }
            // Show prompt if magazine is empty but reserve ammo exists
            if (localPlayerStats.magazine === 0 && localPlayerStats.ammo > 0) {
                showReloadPrompt();
            } else {
                 // Hide prompt/status if not actively reloading
                if (!isReloading) {
                     hideReloadStatus();
                 }
            }
        }

        function showReloadPrompt() {
            if (!reloadStatusElement) return;
            reloadTextElement.textContent = "Reload (R)";
            reloadProgressBarContainer.style.display = 'none'; // Hide progress bar for prompt
            reloadStatusElement.style.display = 'block';
        }

        function showReloadingStatus() {
            if (!reloadStatusElement) return;
            isReloading = true;
            reloadStartTime = Date.now();
            reloadTextElement.textContent = "Reloading...";
            reloadProgressBar.style.width = '0%'; // Reset progress bar
            reloadProgressBarContainer.style.display = 'block'; // Show progress bar
            reloadStatusElement.style.display = 'block';
        }

        function hideReloadStatus() {
            if (reloadStatusElement) {
                reloadStatusElement.style.display = 'none';
            }
        }

        function updateReloadProgress(delta) {
            // Only update if actively reloading and status is visible
            if (!isReloading || !reloadStatusElement || reloadStatusElement.style.display === 'none') return;

            const elapsedTime = Date.now() - reloadStartTime;
            const progress = Math.min(100, (elapsedTime / RELOAD_DURATION) * 100);
            reloadProgressBar.style.width = `${progress}%`;

            // Note: Reload completion is handled by the server sending an 'ammo_update'
        }

        function showDeathScreen() {
            if (!deathScreenElement) return;
            isDead = true;
            killerNameElement.textContent = killerName; // Update killer name
            respawnCountdown = RESPAWN_TIME_SECONDS; // Reset countdown
            respawnTimerElement.textContent = `Respawn in: ${Math.ceil(respawnCountdown)}s`;
            deathScreenElement.style.display = 'flex'; // Show the screen
            if (controls.isLocked) {
                controls.unlock(); // Unlock pointer on death
            }
            // Stop movement input
            moveForward = moveBackward = moveLeft = moveRight = false;
            hideReloadStatus(); // Hide reload status/prompt on death
        }

        function hideDeathScreen() {
            if (deathScreenElement) {
                deathScreenElement.style.display = 'none';
            }
        }

        function onKeyDown(event) {
            // Ignore movement/shooting keys if dead, allow Tab/Escape
            if (isDead && !['Tab', 'Escape'].includes(event.code)) return;
            // Ignore most keys if pointer is not locked
            if (!controls.isLocked && !['Tab', 'Escape'].includes(event.code)) return;

            switch (event.code) {
                case 'KeyW': case 'ArrowUp': moveForward = true; break;
                case 'KeyA': case 'ArrowLeft': moveLeft = true; break;
                case 'KeyS': case 'ArrowDown': moveBackward = true; break;
                case 'KeyD': case 'ArrowRight': moveRight = true; break;
                case 'Space':
                    // Allow jump only if grounded and not dead
                    if (canJump && !isDead) {
                        playerVelocity.y = jumpVelocity;
                        canJump = false; // Prevent double jump until grounded again
                    }
                    break;
                case 'KeyR':
                    // Initiate reload if conditions met
                    if (ws && ws.readyState === WebSocket.OPEN && localPlayerId &&
                        !isDead && !isReloading &&
                        localPlayerStats.magazine < MAX_MAGAZINE && localPlayerStats.ammo > 0)
                    {
                        console.log("Sending reload request...");
                        ws.send(JSON.stringify({ type: 'request_reload' }));
                        showReloadingStatus(); // Show client-side indicator immediately
                    }
                    break;
                case 'Tab':
                    event.preventDefault(); // Prevent tabbing out of the game
                    showScoreboard();
                    break;
                // Allow Escape to unlock pointer (handled by PointerLockControls)
            }
        }

        function onKeyUp(event) {
            // Update movement flags on key release
            switch (event.code) {
                case 'KeyW': case 'ArrowUp': moveForward = false; break;
                case 'KeyA': case 'ArrowLeft': moveLeft = false; break;
                case 'KeyS': case 'ArrowDown': moveBackward = false; break;
                case 'KeyD': case 'ArrowRight': moveRight = false; break;
                case 'Tab':
                    hideScoreboard();
                    break;
            }
        }

        function onMouseDown(event) {
            // Shoot on left click if pointer locked, alive, and not reloading
            if (controls.isLocked && event.button === 0 && !isDead && !isReloading) {
                shoot();
            }
        }

        function shoot() {
            // Check conditions before shooting
            if (!ws || ws.readyState !== WebSocket.OPEN || !localPlayerId ||
                localPlayerStats.health <= 0 || localPlayerStats.magazine <= 0 || isReloading)
            {
                 // If out of ammo but has reserve, show reload prompt
                if (localPlayerStats.magazine <= 0 && localPlayerStats.ammo > 0 && !isReloading && !isDead) {
                    showReloadPrompt();
                }
                // TODO: Add out-of-ammo sound effect?
                return;
            }

            // Get camera direction and position for projectile origin
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);
            const startPos = new THREE.Vector3();
            camera.getWorldPosition(startPos);
            // Offset start position slightly forward from camera to avoid self-collision
            startPos.addScaledVector(direction, 0.6);

            // Send shoot message to server
            ws.send(JSON.stringify({
                type: 'shoot',
                payload: {
                    direction: { x: direction.x, y: direction.y, z: direction.z },
                    startPos: { x: startPos.x, y: startPos.y, z: startPos.z }
                }
            }));

            // --- Client-side prediction (optional but good for responsiveness) ---
            // Decrement local ammo immediately
            if (localPlayerStats.magazine > 0) {
                localPlayerStats.magazine--;
                updateHUD(localPlayerStats.magazine, localPlayerStats.ammo);
                checkReloadPrompt(); // Check if reload needed after shot
            }
            // Play shooting sound effect
            // TODO: Add audio playback for shooting sound
            // Trigger muzzle flash visual effect
            if (muzzleFlash) {
                muzzleFlash.intensity = 2.0; // Make flash bright
                // Set timer to turn off flash quickly
                setTimeout(() => {
                    if (muzzleFlash) muzzleFlash.intensity = 0;
                }, 60); // Flash duration in ms
            }
        }

        function showScoreboard() {
            if (!localPlayerId || !scoreboardElement) return;
            updateScoreboard(); // Refresh data before showing
            scoreboardElement.style.display = 'block';
        }

        function hideScoreboard() {
            if (scoreboardElement) {
                scoreboardElement.style.display = 'none';
            }
        }

        function updateScoreboard() {
            if (!scoreboardTableBody) return;
            scoreboardTableBody.innerHTML = ''; // Clear previous entries

            const playerList = [];
            // Add local player first if connected
            if (localPlayerId) {
                 const localName = localPlayerStats.name || players[localPlayerId]?.name || "You";
                 playerList.push({
                     id: localPlayerId,
                     name: localName,
                     kills: localPlayerStats.kills,
                     deaths: localPlayerStats.deaths,
                     isLocal: true
                 });
            }
            // Add other players
            for (const id in players) {
                if (id !== localPlayerId) {
                    const p = players[id];
                    playerList.push({
                        id: id,
                        name: p.name || `Player_${id.substring(0, 4)}`,
                        kills: p.kills,
                        deaths: p.deaths,
                        isLocal: false
                    });
                }
            }

            // Sort players by kills (descending)
            playerList.sort((a, b) => b.kills - a.kills);

            // Populate table rows
            playerList.forEach(p => {
                const row = scoreboardTableBody.insertRow();
                if (p.isLocal) {
                    row.classList.add('local-player'); // Highlight local player row
                }
                row.insertCell(0).textContent = p.name;
                row.insertCell(1).textContent = p.kills;
                row.insertCell(2).textContent = p.deaths;
            });
        }

        function onWindowResize() {
            // Update camera aspect ratio and renderer size
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            // Labels might need repositioning on resize, handled in updatePlayerLabel
        }

        // --- Movement & Physics Variables ---
        const moveDirection = new THREE.Vector3();
        const rightDirection = new THREE.Vector3();
        const forwardDirection = new THREE.Vector3();
        const playerCollider = new THREE.Box3(); // For obstacle collision
        const collisionCheckVector = new THREE.Vector3(); // Reusable vector for checks

        function animate() {
            requestAnimationFrame(animate); // Loop animation
            const delta = Math.min(clock.getDelta(), 0.1); // Get time delta, cap for stability

            // --- Update Projectiles ---
            for (const id in projectiles) {
                const p = projectiles[id];
                // Move projectile based on its velocity and delta time
                p.mesh.position.x += p.vx * delta;
                p.mesh.position.y += p.vy * delta;
                p.mesh.position.z += p.vz * delta;
                // Optional: Client-side removal after timeout (server is authoritative)
                // if (Date.now() - p.spawnTime > 2500) { // Match server lifetime + buffer
                //     removeProjectile(id);
                // }
            }

            // --- Update Local State Timers ---
            if (isReloading) {
                updateReloadProgress(delta);
            }
            if (isDead && respawnCountdown > 0) {
                respawnCountdown -= delta;
                respawnTimerElement.textContent = `Respawn in: ${Math.max(0, Math.ceil(respawnCountdown))}s`;
                // Optional: Sink player model slowly while dead
                const playerObject = controls.getObject();
                if (playerObject.position.y > 0.5) { // Don't sink below ground
                    playerObject.position.y -= 1.0 * delta; // Sink rate
                }
            }

            // --- Handle Player Movement & Input ---
            if (controls.isLocked === true && localPlayerId && !isDead) {
                const playerObject = controls.getObject(); // The camera group

                // Apply gravity
                playerVelocity.y -= gravity * delta;
                // Update vertical position based on velocity
                playerObject.position.y += playerVelocity.y * delta;

                // Ground check and reset jump
                if (playerObject.position.y < playerEyeLevel) {
                    playerVelocity.y = 0; // Stop falling
                    playerObject.position.y = playerEyeLevel; // Correct position to eye level
                    canJump = true; // Allow jumping again
                }

                // Apply friction/damping to horizontal movement
                playerVelocity.x -= playerVelocity.x * 10.0 * delta;
                playerVelocity.z -= playerVelocity.z * 10.0 * delta;

                // Calculate movement direction based on input flags
                // Z axis: W = +1, S = -1
                // X axis: D = +1, A = -1 (Relative to the 'right' vector)
                moveDirection.z = Number(moveForward) - Number(moveBackward);
                moveDirection.x = Number(moveRight) - Number(moveLeft);
                moveDirection.normalize(); // Ensure consistent speed regardless of diagonal movement

                // Get camera forward direction (on XZ plane)
                camera.getWorldDirection(forwardDirection);
                forwardDirection.y = 0; // Ignore vertical component for movement
                forwardDirection.normalize();

                // Calculate right direction (perpendicular to forward)
                // Use cross product: (Forward x Up) gives Right
                rightDirection.crossVectors(forwardDirection, camera.up).normalize();

                // Calculate target velocity based on input and directions
                const targetVelocityX = (forwardDirection.x * moveDirection.z + rightDirection.x * moveDirection.x) * playerSpeed;
                const targetVelocityZ = (forwardDirection.z * moveDirection.z + rightDirection.z * moveDirection.x) * playerSpeed;

                // Smoothly accelerate towards target velocity (lerp)
                const accelerationFactor = delta * 10.0; // How quickly player accelerates
                playerVelocity.x = THREE.MathUtils.lerp(playerVelocity.x, targetVelocityX, accelerationFactor);
                playerVelocity.z = THREE.MathUtils.lerp(playerVelocity.z, targetVelocityZ, accelerationFactor);

                // Calculate actual movement distance for this frame
                const moveX = playerVelocity.x * delta;
                const moveZ = playerVelocity.z * delta;

                // --- Simple Collision Detection ---
                let collisionX = false;
                let collisionZ = false;
                const currentPos = playerObject.position;

                // Update player collider bounding box for current position
                // Centered at feet level approx.
                const colliderCenter = currentPos.clone().setY(currentPos.y - playerEyeLevel + playerHeight / 2);
                playerCollider.setFromCenterAndSize(colliderCenter, new THREE.Vector3(playerRadius * 2, playerHeight, playerRadius * 2));

                // 1. Check against static obstacles
                obstacles.forEach(obstacle => {
                    if (!obstacle.userData.boundingBox) return; // Skip if no bounding box
                    // Check X movement
                    const colliderX = playerCollider.clone().translate(new THREE.Vector3(moveX, 0, 0));
                    if (colliderX.intersectsBox(obstacle.userData.boundingBox)) {
                        collisionX = true;
                    }
                    // Check Z movement
                    const colliderZ = playerCollider.clone().translate(new THREE.Vector3(0, 0, moveZ));
                    if (colliderZ.intersectsBox(obstacle.userData.boundingBox)) {
                        collisionZ = true;
                    }
                });

                // 2. Check against other players (simple radius check)
                for (const pId in players) {
                    if (pId === localPlayerId || !players[pId].mesh.visible) continue; // Skip self and invisible players

                    // Use the other player's mesh position (which is at their feet level)
                    const otherPlayerFeetPos = players[pId].mesh.position;
                    // Check distance squared for efficiency
                    const collisionRadiusSq = (playerRadius * 2) ** 2; // Use combined radii

                    // Check X movement collision
                    collisionCheckVector.copy(colliderCenter).add(new THREE.Vector3(moveX, 0, 0)); // Check future X position center
                    // Adjust Y of other player for comparison (feet vs feet approx)
                    if (collisionCheckVector.distanceToSquared(otherPlayerFeetPos) < collisionRadiusSq) {
                        collisionX = true;
                    }

                    // Check Z movement collision
                    collisionCheckVector.copy(colliderCenter).add(new THREE.Vector3(0, 0, moveZ)); // Check future Z position center
                    if (collisionCheckVector.distanceToSquared(otherPlayerFeetPos) < collisionRadiusSq) {
                        collisionZ = true;
                    }
                }


                // Apply movement only if no collision detected on that axis
                if (!collisionX) {
                    playerObject.position.x += moveX;
                } else {
                    playerVelocity.x = 0; // Stop movement on collision
                }
                if (!collisionZ) {
                    playerObject.position.z += moveZ;
                } else {
                    playerVelocity.z = 0; // Stop movement on collision
                }

                // --- Send Player Update to Server ---
                if (ws && ws.readyState === WebSocket.OPEN) {
                    const controlObject = controls.getObject(); // Camera group
                    const yaw = controlObject.rotation.y; // Rotation around Y axis
                    // Pitch is rotation of the camera itself (child of controlObject) around X axis
                    let pitch = 0;
                    if (controlObject.children && controlObject.children.length > 0 && controlObject.children[0]) {
                         pitch = controlObject.children[0].rotation.x;
                    }
                    ws.send(JSON.stringify({
                        type: 'player_update',
                        payload: {
                            position: { x: playerObject.position.x, y: playerObject.position.y, z: playerObject.position.z },
                            rotation: { pitch: pitch, yaw: yaw }
                        }
                    }));
                }
            } // End if (controls.isLocked)

            // --- Update Player Labels ---
            // Update labels for all *other* visible players
            for (const id in players) {
                if (id !== localPlayerId && players[id].mesh.visible) {
                    updatePlayerLabel(players[id], players[id].health);
                }
            }

            // --- Render Scene ---
            renderer.render(scene, camera);
        }

    </script>
</body>
</html>