<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prototyp FPS WebGL v4 - Poprawki</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #222; color: white; font-family: sans-serif; }
        canvas { display: block; }
        #hud {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            color: white;
            font-size: 18px;
            z-index: 10;
        }
        #crosshair {
            position: absolute;
            left: 50%;
            top: 50%;
            width: 2px;
            height: 10px;
            background-color: lime;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 10;
        }
         #crosshair::before {
            content: '';
            position: absolute;
            left: -4px;
            top: 4px;
            width: 10px;
            height: 2px;
            background-color: lime;
         }

         .player-label {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.6);
            color: white;
            padding: 2px 5px;
            border-radius: 3px;
            font-size: 12px;
            white-space: nowrap;
            pointer-events: none;
            transform: translateX(-50%);
            text-align: center;
            z-index: 5;
        }
        .health-bar {
            height: 5px;
            background-color: red;
            margin-top: 2px;
        }
         .health-bar-inner {
            height: 100%;
            background-color: lime;
            width: 100%;
         }
         #scoreboard {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.75);
            border: 1px solid #555;
            border-radius: 8px;
            padding: 15px;
            color: white;
            font-size: 14px;
            min-width: 300px;
            z-index: 20;
            display: none;
         }
         #scoreboard table { width: 100%; border-collapse: collapse; }
         #scoreboard th, #scoreboard td { padding: 5px 8px; text-align: left; border-bottom: 1px solid #444; }
         #scoreboard th { font-weight: bold; }
         #scoreboard tr:last-child td { border-bottom: none; }
         #scoreboard .local-player td { font-weight: bold; color: #aaffaa; }

         #connection-status {
             position: absolute;
             top: 10px;
             left: 10px;
             color: #ffcc00;
             background-color: rgba(0,0,0,0.5);
             padding: 5px;
             border-radius: 3px;
             font-size: 12px;
             z-index: 10;
         }

         #top-right-hud {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            z-index: 16;
        }

         #health-hearts {
             display: flex;
             margin-bottom: 5px;
         }

         .heart {
             width: 20px;
             height: 18px;
             margin-left: 3px;
             background-size: contain;
             background-repeat: no-repeat;
             background-position: center;
         }

         .heart-full {
             background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="red"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/></svg>');
         }

         .heart-empty {
              background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/></svg>');
         }

        #event-log {
             /* Positioned under hearts in top-right-hud */
             width: 250px;
             max-height: 150px;
             overflow: hidden;
             display: flex;
             flex-direction: column-reverse;
             z-index: 15;
         }
         .log-message {
             background-color: rgba(0, 0, 0, 0.6);
             color: #eee;
             padding: 4px 8px;
             margin-top: 4px;
             border-radius: 4px;
             font-size: 12px;
             white-space: nowrap;
             overflow: hidden;
             text-overflow: ellipsis;
             animation: fadeOut 5s forwards;
         }
         .log-message.join { color: #88ff88; }
         .log-message.leave { color: #ff8888; }
         .log-message.kill { color: #ffffff; }
         .log-message.kill .attacker { color: #ffdd88; font-weight: bold; }
         .log-message.kill .victim { color: #88ddff; font-weight: bold; }

         @keyframes fadeOut {
             0% { opacity: 1; }
             80% { opacity: 1; }
             100% { opacity: 0; }
         }


         #reload-status {
            position: absolute;
            top: 60%;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px 15px;
            border-radius: 5px;
            font-size: 16px;
            z-index: 12;
            display: none;
            text-align: center;
            min-width: 150px;
         }
         #reload-progress-bar-container {
            width: 100%;
            height: 8px;
            background-color: #555;
            border-radius: 4px;
            margin-top: 5px;
            overflow: hidden;
         }
          #reload-progress-bar {
             width: 0%;
             height: 100%;
             background-color: #4CAF50;
             border-radius: 4px;
             transition: width 0.1s linear;
          }

         #death-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(150, 0, 0, 0.7);
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            z-index: 50;
            display: none;
            text-align: center;
         }
         #death-message { font-size: 36px; margin-bottom: 10px; }
         #killer-info { font-size: 20px; margin-bottom: 20px; }
         #respawn-timer { font-size: 28px; font-weight: bold; }

    </style>
</head>
<body>
    <div id="connection-status">Łączenie...</div>
    <div id="hud">
        Amunicja: <span id="ammo">30 / 100</span>
    </div>
    <div id="top-right-hud">
         <div id="health-hearts"></div>
         <div id="event-log"></div>
    </div>
    <div id="crosshair"></div>
    <div id="player-labels"></div>
    <div id="scoreboard">
        <h2>Tablica Wyników</h2>
        <table id="scoreboard-table">
            <thead>
                <tr><th>Gracz</th><th>Zabójstwa</th><th>Zgony</th></tr>
            </thead>
            <tbody></tbody>
        </table>
    </div>
    <div id="reload-status">
        <span id="reload-text"></span>
        <div id="reload-progress-bar-container" style="display: none;">
            <div id="reload-progress-bar"></div>
        </div>
    </div>
    <div id="death-screen">
        <div id="death-message">ZGINĄŁEŚ!</div>
        <div id="killer-info">Zabił Cię: <span id="killer-name">Nieznany</span></div>
        <div id="respawn-timer">Odrodzenie za: 3s</div>
    </div>


    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // --- Global variables ---
        let scene, camera, renderer, controls;
        let playerVelocity = new THREE.Vector3();
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let canJump = true;

        let localPlayerId = null;
        let players = {}; // { id: { mesh, labelElement, healthBarElement, kills, deaths, name, health, weaponMesh? } }
        let localPlayerStats = { kills: 0, deaths: 0, health: 100, magazine: 0, ammo: 0 };
        let projectiles = {};
        let obstacles = [];

        // --- FPV Weapon variables ---
        let weaponModel;
        let muzzleFlash;

        // --- Local state variables ---
        let isReloading = false;
        let reloadStartTime = 0;
        let isDead = false;
        let respawnCountdown = 0;
        let killerName = 'Unknown';

        // --- Constants ---
        const clock = new THREE.Clock();
        const playerEyeLevel = 1.6;
        const playerHeight = 1.8;
        const playerRadius = 0.4; // For player-player collision
        const playerSpeed = 5.0;
        const gravity = 18.0;
        const jumpVelocity = 7.5;
        const START_HEALTH = 100;
        const MAX_MAGAZINE = 30;
        const RELOAD_DURATION = 2000; // ms
        const RESPAWN_TIME_SECONDS = 3; // s

        // --- DOM Elements ---
        let ws;
        const connectionStatusElement = document.getElementById('connection-status');
        const scoreboardElement = document.getElementById('scoreboard');
        const scoreboardTableBody = scoreboardElement.querySelector('#scoreboard-table tbody');
        const eventLogElement = document.getElementById('event-log');
        const healthHeartsElement = document.getElementById('health-hearts');
        const reloadStatusElement = document.getElementById('reload-status');
        const reloadTextElement = document.getElementById('reload-text');
        const reloadProgressBarContainer = document.getElementById('reload-progress-bar-container');
        const reloadProgressBar = document.getElementById('reload-progress-bar');
        const deathScreenElement = document.getElementById('death-screen');
        const killerNameElement = document.getElementById('killer-name');
        const respawnTimerElement = document.getElementById('respawn-timer');
        const ammoElement = document.getElementById('ammo');

        // --- Initialization ---
        init();

        // --- Functions ---

        function init() {
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // Light blue sky
            scene.fog = new THREE.Fog(0x87CEEB, 15, 70); // Add fog for depth

            // Camera setup
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.y = playerEyeLevel;

            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Softer shadows
            document.body.appendChild(renderer.domElement);

            // PointerLockControls setup
            controls = new PointerLockControls(camera, document.body);
            scene.add(controls.getObject()); // Add the controls object (which contains the camera) to the scene
            controls.getObject().position.y = playerEyeLevel; // Set initial height correctly

            // PointerLock event listeners
            document.addEventListener('click', () => {
                if (!controls.isLocked && !isDead) { // Lock only if not already locked and player is alive
                    controls.lock();
                }
            });
            controls.addEventListener('lock', () => console.log('Pointer locked'));
            controls.addEventListener('unlock', () => {
                console.log('Pointer unlocked');
                moveForward = moveBackward = moveLeft = moveRight = false; // Stop movement when cursor is unlocked
            });

            // Lighting setup
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
            dirLight.position.set(15, 20, 10);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            dirLight.shadow.camera.near = 0.5;
            dirLight.shadow.camera.far = 60;
            dirLight.shadow.camera.left = -25;
            dirLight.shadow.camera.right = 25;
            dirLight.shadow.camera.top = 25;
            dirLight.shadow.camera.bottom = -25;
            scene.add(dirLight);
            // scene.add( new THREE.CameraHelper( dirLight.shadow.camera ) ); // Debug shadow camera

            // Ground plane
            const groundGeometry = new THREE.PlaneGeometry(100, 100);
            const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x4a5d23, roughness: 0.9 }); // Dark green grass
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2; // Rotate to be horizontal
            ground.receiveShadow = true;
            scene.add(ground);

            // Obstacles (Boxes)
            const boxGeometry = new THREE.BoxGeometry(1, 1, 1); // Base size
            const boxMaterial = new THREE.MeshStandardMaterial({ color: 0xA0522D, roughness: 0.7 }); // Brown material
            for (let i = 0; i < 15; ++i) {
                const sizeX = Math.random() * 2 + 1;
                const sizeY = Math.random() * 2 + 1;
                const sizeZ = Math.random() * 2 + 1;
                const box = new THREE.Mesh(boxGeometry.clone(), boxMaterial.clone()); // Clone geometry and material
                box.scale.set(sizeX, sizeY, sizeZ);
                box.position.set(Math.random() * 50 - 25, sizeY / 2, Math.random() * 50 - 25); // Position randomly, standing on ground
                box.castShadow = true;
                box.receiveShadow = true;
                scene.add(box);

                // Prepare for collision detection
                box.geometry.computeBoundingBox(); // Calculate AABB for base geometry
                box.userData.boundingBox = new THREE.Box3(); // Create empty Box3 in userData
                box.updateMatrixWorld(true); // Ensure world matrix is updated
                // Copy and transform the geometry's bounding box to world coordinates
                box.userData.boundingBox.copy(box.geometry.boundingBox).applyMatrix4(box.matrixWorld);
                obstacles.push(box); // Add MESH to obstacles array
                // scene.add(new THREE.Box3Helper(box.userData.boundingBox, 0xffff00)); // Debug bounding boxes
            }

            // FPV weapon model setup
            weaponModel = createWeaponModel();
            camera.add(weaponModel); // Attach weapon to camera
            positionWeaponModel(); // Position weapon relative to camera

            // Muzzle flash light setup
            muzzleFlash = new THREE.PointLight(0xffcc66, 0, 5, 1); // Color, Intensity(0=off), Range, Decay
            muzzleFlash.position.set(0.1, -0.05, -0.5); // Position in front of barrel (relative to weapon)
            weaponModel.add(muzzleFlash);

            // User input event listeners
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousedown', onMouseDown);
            window.addEventListener('resize', onWindowResize);

            // Initial UI setup
            updateHealthHearts(); // Initialize hearts display (empty)

            // Start WebSocket connection and animation loop
            connectWebSocket();
            animate();
        }

        function createWeaponModel() {
            // Creates the FPV weapon model geometry and materials
            const weaponGroup = new THREE.Group();
            const gunMaterial = new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.6, roughness: 0.4 });

            // Main body
            const body = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.15, 0.6), gunMaterial);
            body.position.z = -0.2;
            weaponGroup.add(body);

            // Barrel
            const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.03, 0.4, 16), gunMaterial);
            barrel.position.z = -0.6;
            barrel.rotation.x = Math.PI / 2;
            weaponGroup.add(barrel);

            // Magazine
            const magazine = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.2, 0.15), gunMaterial);
            magazine.position.set(0, -0.15, -0.2);
            weaponGroup.add(magazine);

            // Grip
            const grip = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.2, 0.08), gunMaterial);
            grip.position.set(0, -0.08, 0.05);
            grip.rotation.x = -Math.PI / 10;
            weaponGroup.add(grip);

            // Enable shadows for the weapon
            weaponGroup.castShadow = true;
            weaponGroup.traverse(child => { if (child.isMesh) child.castShadow = true; });

            return weaponGroup;
        }

        function positionWeaponModel() {
            // Positions the FPV weapon relative to the camera
            if (!weaponModel) return;
            weaponModel.position.set(0.25, -0.25, -0.7); // Right, Down, Forward from camera
            weaponModel.rotation.set(0, -Math.PI / 128, 0); // Slight rotation
        }

        // Creates the 3rd person player model
        function createPlayerModel() {
            const playerGroup = new THREE.Group();

            // Materials
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: Math.random() * 0xAAAAAA + 0x555555, roughness: 0.6 });
            const headMaterial = new THREE.MeshStandardMaterial({ color: 0xffdbac, roughness: 0.5 }); // Skin color
            const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0x111111 }); // Black eyes
            const mouthMaterial = new THREE.MeshBasicMaterial({ color: 0x880000 }); // Dark red mouth

            // Dimensions
            const headRadius = 0.2;
            const torsoHeight = 0.7;
            const torsoWidth = 0.4;
            const limbThickness = 0.15; // Use BoxGeometry thickness
            const armLength = 0.6;
            const legHeight = 0.8;

            // Head (Sphere)
            const headGeometry = new THREE.SphereGeometry(headRadius, 16, 12);
            const headMesh = new THREE.Mesh(headGeometry, headMaterial);
            const headY = legHeight + torsoHeight - headRadius * 0.5; // Y position of head center
            headMesh.position.y = headY;
            headMesh.castShadow = true;
            playerGroup.add(headMesh);

            // --- FACIAL FEATURES (relative to headMesh) ---
            const eyeRadius = 0.03;
            const eyeY = headY + headRadius * 0.2;
            const eyeZ = headRadius * 0.85; // Forward placement
            const eyeX = headRadius * 0.4;

            const leftEye = new THREE.Mesh(new THREE.SphereGeometry(eyeRadius, 8, 8), eyeMaterial);
            leftEye.position.set(-eyeX, eyeY, eyeZ);
            playerGroup.add(leftEye); // Add directly to player group

            const rightEye = new THREE.Mesh(new THREE.SphereGeometry(eyeRadius, 8, 8), eyeMaterial);
            rightEye.position.set(eyeX, eyeY, eyeZ);
            playerGroup.add(rightEye);

            const noseRadius = 0.04;
            const noseMesh = new THREE.Mesh(new THREE.SphereGeometry(noseRadius, 6, 6), headMaterial); // Skin color nose
            noseMesh.position.set(0, headY - headRadius * 0.1, headRadius * 0.8);
            playerGroup.add(noseMesh);

            const mouthGeom = new THREE.TorusGeometry(0.06, 0.015, 8, 12, Math.PI); // Half torus for smile
            const mouthMesh = new THREE.Mesh(mouthGeom, mouthMaterial);
            mouthMesh.position.set(0, headY - headRadius * 0.4, headRadius * 0.75);
            mouthMesh.rotation.z = Math.PI; // Flip upside down
            playerGroup.add(mouthMesh);
            // --- END FACIAL FEATURES ---

            // Torso (Box)
            const torsoGeometry = new THREE.BoxGeometry(torsoWidth, torsoHeight, torsoWidth * 0.6);
            const torsoMesh = new THREE.Mesh(torsoGeometry, bodyMaterial);
            torsoMesh.position.y = legHeight + torsoHeight / 2;
            torsoMesh.castShadow = true;
            playerGroup.add(torsoMesh);

            // --- ARMS (Modified for holding weapon pose) ---
            const armGeometry = new THREE.BoxGeometry(limbThickness, armLength, limbThickness);

            // Left Arm
            const leftArmMesh = new THREE.Mesh(armGeometry, bodyMaterial);
            leftArmMesh.position.set(-(torsoWidth / 2 + limbThickness * 0.4), legHeight + torsoHeight * 0.5, 0.1); // Move forward (Z) and slightly lower (Y)
            leftArmMesh.rotation.set(Math.PI / 3, 0, Math.PI / 6); // Rotate forward (X) and slightly inward (Z)
            leftArmMesh.castShadow = true;
            playerGroup.add(leftArmMesh);

            // Right Arm (Clone and mirror)
            const rightArmMesh = leftArmMesh.clone();
            rightArmMesh.position.x *= -1; // Mirror position X
            rightArmMesh.rotation.z *= -1; // Mirror rotation Z
            // rightArmMesh.rotation.y *= -1; // Mirror rotation Y (if needed)
            playerGroup.add(rightArmMesh);
            // --- END ARMS ---


            // Legs (Box)
            const legGeometry = new THREE.BoxGeometry(limbThickness * 1.2, legHeight, limbThickness * 1.2);
            const leftLegMesh = new THREE.Mesh(legGeometry, bodyMaterial);
            leftLegMesh.position.set(-(torsoWidth / 4), legHeight / 2, 0);
            leftLegMesh.castShadow = true;
            playerGroup.add(leftLegMesh);

            const rightLegMesh = leftLegMesh.clone();
            rightLegMesh.position.x *= -1;
            playerGroup.add(rightLegMesh);

            // Set group origin to feet level
            playerGroup.position.set(0, 0, 0);

            // Enable shadows for all parts
            playerGroup.traverse(child => {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true; // Model can receive shadows too
                }
            });

            // Add placeholder weapon (optional, FPV weapon is separate)
            // addWeaponToPlayerModel(playerGroup); // We hide/show this separately if needed

            return playerGroup;
        }


        // Adds a simple placeholder weapon to the 3rd person model
        function addWeaponToPlayerModel(playerGroup) {
            const weaponMaterial = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.7 });
            const simpleWeapon = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 0.5), weaponMaterial);
            // Position relative to player group origin (feet) - adjust by trial & error
            simpleWeapon.position.set(0, playerHeight * 0.65, 0.3); // Roughly chest height, forward
            simpleWeapon.rotation.set(0, 0, 0); // Basic rotation
            simpleWeapon.castShadow = true;
            playerGroup.add(simpleWeapon);
            playerGroup.userData.weaponMesh = simpleWeapon; // Store reference
            return simpleWeapon;
        }


        function connectWebSocket() {
            const wsUrl = `ws://localhost:8080`; // Use localhost or your server address
            // const wsUrl = `ws://${window.location.hostname}:8080`; // Use if server is on same host
            console.log(`Connecting to ${wsUrl}...`);
            updateConnectionStatus('Connecting...');
            ws = new WebSocket(wsUrl);

            ws.onopen = () => {
                console.log("Connected to WebSocket server.");
                updateConnectionStatus('Connected');
            };

            ws.onmessage = (event) => {
                try {
                    const message = JSON.parse(event.data);
                    handleServerMessage(message);
                } catch (error) {
                    console.error("Error processing server message:", error, "Received:", event.data);
                }
            };

            ws.onerror = (error) => {
                console.error("WebSocket Error:", error);
                updateConnectionStatus('Connection Error!');
                updateHUD(0, 0); // Reset ammo HUD
                updateHealthHearts(); // Reset hearts
                resetLocalState();
            };

            ws.onclose = () => {
                console.log("Disconnected from WebSocket server.");
                updateConnectionStatus('Disconnected');
                updateHUD(0, 0);
                updateHealthHearts();
                resetLocalState();

                // Clean up scene on disconnect
                for (const id in players) removePlayer(id);
                players = {};
                for (const id in projectiles) removeProjectile(id);
                projectiles = {};
                updateScoreboard(); // Clear scoreboard
            };
        }

        function resetLocalState() {
            // Resets client state on disconnect/error
            localPlayerId = null;
            localPlayerStats = { kills: 0, deaths: 0, health: 0, magazine: 0, ammo: 0 };
            isReloading = false;
            isDead = true; // Consider disconnected player as dead
            hideReloadStatus();
            hideScoreboard();
            hideDeathScreen(); // Don't show death screen on simple disconnect
        }

        function updateConnectionStatus(status) {
            // Updates the connection status display
            if (connectionStatusElement) {
                connectionStatusElement.textContent = status;
                connectionStatusElement.style.display = 'block';
                if (status === 'Connected') {
                    connectionStatusElement.style.color = '#00ff00'; // Green
                    setTimeout(() => { if (connectionStatusElement.textContent === 'Connected') connectionStatusElement.style.display = 'none'; }, 3000);
                } else if (status === 'Disconnected' || status.includes('Error')) {
                    connectionStatusElement.style.color = 'red'; // Red
                } else {
                    connectionStatusElement.style.color = '#ffcc00'; // Yellow for 'Connecting...'
                }
            }
        }

        function handleServerMessage(message) {
            // Handles messages received from the WebSocket server
             // console.log("[Received]", message.type, message.payload); // DEBUG: Log all incoming messages
            switch (message.type) {
                case 'init': // Initial state on connection
                    localPlayerId = message.payload.id;
                    console.log(`Received ID: ${localPlayerId}`);
                    // Clear old data
                    for (const id in players) removePlayer(id);
                    players = {};
                    for (const id in projectiles) removeProjectile(id);
                    projectiles = {};

                    isDead = false; // Assume alive on init
                    hideDeathScreen();

                    // Process initial player list
                    for (const id in message.payload.players) {
                        const pData = message.payload.players[id];
                        if (id === localPlayerId) {
                            // Set local player position and stats
                            controls.getObject().position.set(pData.x, playerEyeLevel, pData.z);
                            playerVelocity.set(0, 0, 0); // Reset velocity
                            localPlayerStats = { name: pData.name, kills: pData.kills, deaths: pData.deaths, health: pData.health, magazine: pData.magazine, ammo: pData.ammo };
                            updateHUD(pData.magazine, pData.ammo);
                            updateHealthHearts();
                            checkReloadPrompt();
                        } else {
                            addOrUpdatePlayer(pData); // Add other players
                        }
                    }
                    // Add existing projectiles
                    message.payload.projectiles?.forEach(pData => addOrUpdateProjectile(pData));
                    updateScoreboard(); // Update scoreboard with initial data
                    break;

                case 'player_joined':
                    addLogMessage(`${message.payload.name} joined the game.`, 'join');
                    if (message.payload.id !== localPlayerId) {
                        addOrUpdatePlayer(message.payload);
                    }
                    if (scoreboardElement.style.display === 'block') {
                        updateScoreboard();
                    }
                    break;

                case 'player_left':
                    addLogMessage(`${message.payload.name || 'Player'} left the game.`, 'leave');
                    if (message.payload.id !== localPlayerId) {
                        removePlayer(message.payload.id);
                    }
                    if (scoreboardElement.style.display === 'block') {
                        updateScoreboard();
                    }
                    break;

                case 'game_state':
                    let localPlayerDiedThisTick = false;
                    // Update all players based on server state
                    for (const id in message.payload.players) {
                        const pData = message.payload.players[id];
                        if (id === localPlayerId) {
                             // console.log(`[Game State Received] Local player ${id} health from server: ${pData.health}`); // DEBUG LOG

                            // Detect if local player just died
                            if (localPlayerStats.health > 0 && pData.health <= 0 && !isDead) {
                                localPlayerDiedThisTick = true;
                                console.log("Local player death detected.");
                            }
                            // Update local stats (server is authoritative)
                            localPlayerStats.kills = pData.kills;
                            localPlayerStats.deaths = pData.deaths;
                            localPlayerStats.health = pData.health;
                            localPlayerStats.magazine = pData.magazine;
                            localPlayerStats.ammo = pData.ammo;

                            // Update UI
                             // console.log(`    Updating hearts with health: ${localPlayerStats.health}`); // DEBUG LOG
                            updateHUD(pData.magazine, pData.ammo);
                            updateHealthHearts(); // THIS is the crucial call for heart UI
                            checkReloadPrompt();

                            // Ensure 'isDead' flag is correct
                            if (pData.health > 0 && isDead) {
                                isDead = false;
                                hideDeathScreen();
                            }

                        } else {
                            addOrUpdatePlayer(pData); // Update remote players
                        }
                    }

                    // Remove projectiles marked for removal by server
                    message.payload.removedProjectiles?.forEach(projId => removeProjectile(projId));

                    // Process hit events (e.g., show hit marker)
                    message.payload.hits?.forEach(hit => {
                        if (hit.targetId === localPlayerId) {
                            console.log(`You were hit by ${hit.attackerName}! Health: ${hit.newHealth}`);
                            // Add visual hit feedback here (e.g., red flash)
                        }
                        // Health bar update is handled by addOrUpdatePlayer via game_state.players
                    });

                    // Process death events for the event log and death screen
                    message.payload.deaths?.forEach(death => {
                        const victimName = death.victimName || 'Unknown';
                        const attackerName = death.attackerName || 'Unknown';
                        const attackerSpan = `<span class="attacker">${attackerName}</span>`;
                        const victimSpan = `<span class="victim">${victimName}</span>`;
                        let killMsg = (death.victimId === death.attackerId)
                            ? `${victimSpan} committed suicide.`
                            : `${attackerSpan} defeated ${victimSpan}.`;
                        addLogMessage(killMsg, 'kill');

                        // If local player died this tick, show death screen
                        if (death.victimId === localPlayerId && localPlayerDiedThisTick) {
                            killerName = attackerName; // Store killer name
                            showDeathScreen();
                        }
                    });

                    // Update scoreboard if visible
                    if (scoreboardElement.style.display === 'block') {
                        updateScoreboard();
                    }
                    break;

                case 'projectile_created': // New projectile from server
                    addOrUpdateProjectile(message.payload);
                    break;

                case 'ammo_update': // Received after reload or shot confirmation
                    if (localPlayerId) {
                        localPlayerStats.magazine = message.payload.magazine;
                        localPlayerStats.ammo = message.payload.ammo;
                        updateHUD(message.payload.magazine, message.payload.ammo);
                        if (isReloading) { // If reloading, this message confirms completion
                            isReloading = false;
                            hideReloadStatus();
                        }
                        checkReloadPrompt(); // Re-check reload prompt status
                    }
                    break;

                case 'player_respawned':
                    const respawnedData = message.payload;
                    if (respawnedData.id === localPlayerId) {
                        // Local player respawned
                        console.log("You have respawned!");
                        isDead = false;
                        hideDeathScreen();
                        controls.getObject().position.set(respawnedData.x, playerEyeLevel, respawnedData.z);
                        playerVelocity.set(0, 0, 0);
                        // Update local stats from respawn data
                        localPlayerStats.health = respawnedData.health;
                        localPlayerStats.magazine = respawnedData.magazine;
                        localPlayerStats.ammo = respawnedData.ammo;
                        updateHUD(respawnedData.magazine, respawnedData.ammo);
                        updateHealthHearts();
                        checkReloadPrompt();
                        // Optionally re-lock cursor if needed
                        // if (!controls.isLocked) controls.lock();
                    } else {
                        // Another player respawned - update their visibility and position
                        if (players[respawnedData.id]) {
                            const player = players[respawnedData.id];
                            player.mesh.visible = true; // Make sure mesh is visible
                            player.mesh.position.set(respawnedData.x, 0, respawnedData.z);
                            // Health/ammo will be updated by the next game_state
                            if (player.weaponMesh) player.weaponMesh.visible = true; // Show weapon too
                        } else {
                            // If player wasn't known, add them (might happen with packet loss)
                            addOrUpdatePlayer(respawnedData);
                        }
                    }
                    break;
            }
        }

        function addLogMessage(message, type = 'info') {
            // Adds a message to the event log UI
            if (!eventLogElement) return;
            const messageDiv = document.createElement('div');
            messageDiv.className = `log-message ${type}`;
            messageDiv.innerHTML = message; // Use innerHTML to allow styled spans
            eventLogElement.appendChild(messageDiv); // Appends to bottom due to flex-reverse

            // Remove the message after the fadeOut animation completes
            setTimeout(() => {
                if (messageDiv.parentNode === eventLogElement) {
                    eventLogElement.removeChild(messageDiv);
                }
            }, 5500); // Slightly longer than animation

            // Limit the number of messages in the log
            const maxMessages = 5;
            while (eventLogElement.children.length > maxMessages) {
                if (eventLogElement.firstChild) {
                    eventLogElement.removeChild(eventLogElement.firstChild);
                } else {
                    break; // Safety break
                }
            }
        }

        function addOrUpdatePlayer(playerData) {
            // Adds a new player mesh or updates an existing one
            if (!playerData || !playerData.id) return;
            let player = players[playerData.id];

            if (!player) {
                // --- Create New Player ---
                const playerModel = createPlayerModel(); // Create the 3D mesh
                playerModel.position.set(playerData.x, 0, playerData.z); // Set initial position (Y=0 for feet)
                scene.add(playerModel);

                // Create HTML label (name + health bar)
                const labelDiv = document.createElement('div');
                labelDiv.className = 'player-label';
                labelDiv.innerHTML = `
                    ${playerData.name || 'Unknown'}
                    <div class="health-bar"><div class="health-bar-inner"></div></div>
                 `;
                document.getElementById('player-labels').appendChild(labelDiv);
                const healthBarInner = labelDiv.querySelector('.health-bar-inner');

                // Store player data locally
                players[playerData.id] = {
                    id: playerData.id, name: playerData.name, mesh: playerModel,
                    labelElement: labelDiv, healthBarElement: healthBarInner,
                    health: playerData.health, kills: playerData.kills, deaths: playerData.deaths,
                    weaponMesh: playerModel.userData.weaponMesh // Store reference if created
                };
                player = players[playerData.id];
                console.log(`Added player: ${playerData.name} (${playerData.id})`);
            } else {
                // --- Update Existing Player ---
                // Smoothly interpolate position and rotation
                player.mesh.position.lerp(new THREE.Vector3(playerData.x, 0, playerData.z), 0.3); // Adjust lerp factor for smoothness
                player.mesh.rotation.y = THREE.MathUtils.lerp(player.mesh.rotation.y, playerData.yaw, 0.5); // Lerp yaw

                // Update stored stats
                player.health = playerData.health;
                player.kills = playerData.kills;
                player.deaths = playerData.deaths;
            }

            // Set visibility based on health
            const isAlive = playerData.health > 0;
            player.mesh.visible = isAlive;
            player.labelElement.style.display = isAlive ? 'block' : 'none';
            if (player.weaponMesh) { // Hide/show placeholder weapon too
                player.weaponMesh.visible = isAlive;
            }

            // Update label position and health bar if alive
            if (isAlive) {
                updatePlayerLabel(player, playerData.health);
            }
        }

        function removePlayer(playerId) {
            // Removes a player's mesh and data
            const player = players[playerId];
            if (player) {
                console.log(`Removing player: ${player.name} (${playerId})`);
                scene.remove(player.mesh); // Remove mesh from scene
                // Dispose geometry and materials to free memory
                player.mesh.traverse(child => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(mat => mat.dispose());
                        } else {
                            child.material.dispose();
                        }
                    }
                });
                // Remove HTML label
                if (player.labelElement && player.labelElement.parentNode) {
                    player.labelElement.parentNode.removeChild(player.labelElement);
                }
                delete players[playerId]; // Remove from local players object
            }
        }

        const LABEL_Y_OFFSET = playerHeight + 0.3; // Offset for label above player head

        function updatePlayerLabel(player, health) {
            // Updates the health bar and position of a player's HTML label
            if (!player || !player.labelElement) return;

            // Update health bar width
            const healthPerc = Math.max(0, Math.min(100, (health / START_HEALTH) * 100));
            if (player.healthBarElement) {
                player.healthBarElement.style.width = `${healthPerc}%`;
            }

            // Update label position on screen
            const mesh = player.mesh;
            const label = player.labelElement;
            const worldPosition = new THREE.Vector3();
            mesh.getWorldPosition(worldPosition); // Get world position of mesh origin (feet)
            worldPosition.y += LABEL_Y_OFFSET; // Adjust height to be above head
            const screenPosition = worldPosition.project(camera); // Project 3D position to 2D screen coordinates

            // Check if label is within camera view and in front of the camera
            const isVisible = Math.abs(screenPosition.x) <= 1 && Math.abs(screenPosition.y) <= 1 && screenPosition.z > 0;

            if (isVisible && player.mesh.visible) { // Show label only if mesh is visible and on screen
                const x = (screenPosition.x * 0.5 + 0.5) * window.innerWidth;
                const y = (-screenPosition.y * 0.5 + 0.5) * window.innerHeight; // Invert Y-axis
                label.style.left = `${x}px`;
                label.style.top = `${y}px`;
                label.style.display = 'block';
            } else {
                label.style.display = 'none'; // Hide label if off-screen or mesh is hidden
            }
        }

        function addOrUpdateProjectile(projData) {
            // Adds or updates a projectile mesh
            if (!projData || !projData.id || projectiles[projData.id]) return; // Basic validation/duplicate check

            const projGeometry = new THREE.SphereGeometry(0.06, 6, 6); // Small sphere
            const projMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 }); // Bright yellow
            const mesh = new THREE.Mesh(projGeometry, projMaterial);
            mesh.position.set(projData.x, projData.y, projData.z);
            scene.add(mesh);

            projectiles[projData.id] = {
                id: projData.id, mesh: mesh,
                vx: projData.vx, vy: projData.vy, vz: projData.vz,
                spawnTime: Date.now() // Store spawn time for client-side cleanup
            };
        }

        function removeProjectile(projId) {
            // Removes a projectile mesh from the scene and local state
            const proj = projectiles[projId];
            if (proj) {
                scene.remove(proj.mesh);
                proj.mesh.geometry.dispose();
                proj.mesh.material.dispose();
                delete projectiles[projId];
            }
        }

        // Updates the ammo display in the HUD
        function updateHUD(magazine, ammo) {
            if (ammoElement) {
                ammoElement.textContent = `${magazine} / ${ammo}`;
            }
        }

        // Updates the health hearts display
        function updateHealthHearts() {
            if (!healthHeartsElement) return;
            healthHeartsElement.innerHTML = ''; // Clear existing hearts
            const currentHealth = localPlayerStats?.health ?? 0;
             // console.log(`[updateHealthHearts] Current health: ${currentHealth}`); // DEBUG LOG
            const numFullHearts = Math.ceil(Math.max(0, currentHealth) / 10); // 1 heart per 10 HP
             // console.log(`    Calculated full hearts: ${numFullHearts}`); // DEBUG LOG

            for (let i = 0; i < 10; i++) { // Always display 10 hearts
                const heartDiv = document.createElement('div');
                heartDiv.classList.add('heart');
                if (i < numFullHearts) {
                    heartDiv.classList.add('heart-full'); // Add full heart class
                } else {
                    heartDiv.classList.add('heart-empty'); // Add empty heart class
                }
                healthHeartsElement.appendChild(heartDiv);
            }
        }

        // Checks if the reload prompt should be shown
        function checkReloadPrompt() {
            if (isReloading || isDead || !localPlayerId) {
                hideReloadStatus(); // Hide if reloading, dead, or disconnected
                return;
            }

            // Show prompt if magazine is empty but reserve ammo exists
            if (localPlayerStats.magazine === 0 && localPlayerStats.ammo > 0) {
                showReloadPrompt();
            } else {
                // Hide prompt if not reloading (covers case where mag is full or no reserve)
                if (!isReloading) {
                    hideReloadStatus();
                }
            }
        }

        // Shows only the "Reload (R)" text prompt
        function showReloadPrompt() {
            if (!reloadStatusElement) return;
            reloadTextElement.textContent = "Reload (R)";
            reloadProgressBarContainer.style.display = 'none'; // Hide progress bar
            reloadStatusElement.style.display = 'block';
        }

        // Shows "Reloading..." text and progress bar
        function showReloadingStatus() {
            if (!reloadStatusElement) return;
            isReloading = true; // Set reloading flag
            reloadStartTime = Date.now(); // Record start time
            reloadTextElement.textContent = "Reloading...";
            reloadProgressBar.style.width = '0%'; // Reset progress bar
            reloadProgressBarContainer.style.display = 'block'; // Show progress bar container
            reloadStatusElement.style.display = 'block';
        }

        // Hides the entire reload status element
        function hideReloadStatus() {
            if (reloadStatusElement) {
                reloadStatusElement.style.display = 'none';
            }
        }

        // Updates the reload progress bar visually
        function updateReloadProgress(delta) {
            if (!isReloading || !reloadStatusElement || reloadStatusElement.style.display === 'none') return;

            const elapsedTime = Date.now() - reloadStartTime;
            const progress = Math.min(100, (elapsedTime / RELOAD_DURATION) * 100);
            reloadProgressBar.style.width = `${progress}%`;

            // Note: Actual reload completion is handled by server sending 'ammo_update'
        }

        // Shows the death screen overlay
        function showDeathScreen() {
            if (!deathScreenElement) return;
            isDead = true; // Set dead flag
            killerNameElement.textContent = killerName; // Display killer name
            respawnCountdown = RESPAWN_TIME_SECONDS; // Start countdown timer
            respawnTimerElement.textContent = `Respawn in: ${Math.ceil(respawnCountdown)}s`;
            deathScreenElement.style.display = 'flex'; // Show the overlay
            if (controls.isLocked) {
                controls.unlock(); // Unlock cursor on death
            }
            moveForward = moveBackward = moveLeft = moveRight = false; // Stop any movement
            hideReloadStatus(); // Hide reload prompt/bar
        }

        // Hides the death screen overlay
        function hideDeathScreen() {
            if (deathScreenElement) {
                deathScreenElement.style.display = 'none';
            }
        }

        // Handles key down events for movement, jumping, reloading, scoreboard
        function onKeyDown(event) {
            // Ignore most input if dead (allow Tab for scoreboard, Escape for menu/unlock)
            if (isDead && event.code !== 'Tab' && event.code !== 'Escape') return;
            // Ignore movement keys if cursor isn't locked
            if (!controls.isLocked && !['Tab', 'Escape'].includes(event.code)) return;

            switch (event.code) {
                case 'KeyW': case 'ArrowUp': moveForward = true; break;
                case 'KeyA': case 'ArrowLeft': moveLeft = true; break;
                case 'KeyS': case 'ArrowDown': moveBackward = true; break;
                case 'KeyD': case 'ArrowRight': moveRight = true; break;
                case 'Space':
                    if (canJump && !isDead) { // Allow jump only if alive and able
                        playerVelocity.y = jumpVelocity;
                        canJump = false;
                    }
                    break;
                case 'KeyR': // Reload
                    // Check conditions: connected, alive, not already reloading, mag not full, reserve ammo exists
                    if (ws && ws.readyState === WebSocket.OPEN && localPlayerId && !isDead && !isReloading &&
                        localPlayerStats.magazine < MAX_MAGAZINE && localPlayerStats.ammo > 0) {
                        console.log("Sending reload request...");
                        ws.send(JSON.stringify({ type: 'request_reload' }));
                        showReloadingStatus(); // Show reloading UI immediately
                    }
                    break;
                case 'Tab': // Scoreboard
                    event.preventDefault(); // Prevent default browser tab behavior
                    showScoreboard();
                    break;
            }
        }

        // Handles key up events to stop movement
        function onKeyUp(event) {
            // No need to check isDead here, releasing key should always stop movement intent
            switch (event.code) {
                case 'KeyW': case 'ArrowUp': moveForward = false; break;
                case 'KeyA': case 'ArrowLeft': moveLeft = false; break;
                case 'KeyS': case 'ArrowDown': moveBackward = false; break;
                case 'KeyD': case 'ArrowRight': moveRight = false; break;
                case 'Tab': // Hide scoreboard on key release
                    hideScoreboard();
                    break;
            }
        }

        // Handles mouse down events for shooting
        function onMouseDown(event) {
            // Shoot on left click if cursor locked, alive, and not reloading
            if (controls.isLocked && event.button === 0 && !isDead && !isReloading) {
                shoot();
            }
        }

        // Handles the shooting logic
        function shoot() {
            // Check conditions: connected, alive, has ammo in mag, not reloading
            if (!ws || ws.readyState !== WebSocket.OPEN || !localPlayerId || localPlayerStats.health <= 0 || localPlayerStats.magazine <= 0 || isReloading) {
                // If out of ammo in mag but has reserve, show prompt
                if (localPlayerStats.magazine <= 0 && localPlayerStats.ammo > 0 && !isReloading && !isDead) {
                    console.log("Empty magazine - show prompt!");
                    showReloadPrompt();
                }
                return; // Cannot shoot
            }

            // Calculate projectile direction and start position
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction); // Direction camera is facing
            const startPos = new THREE.Vector3();
            camera.getWorldPosition(startPos); // Position of the camera
            startPos.addScaledVector(direction, 0.6); // Start slightly in front of camera

            // Send shoot message to server
            ws.send(JSON.stringify({
                type: 'shoot',
                payload: {
                    direction: { x: direction.x, y: direction.y, z: direction.z },
                    startPos: { x: startPos.x, y: startPos.y, z: startPos.z }
                }
            }));

            // --- Client-side prediction/effects ---
            if (localPlayerStats.magazine > 0) {
                 localPlayerStats.magazine--; // Decrease ammo locally for immediate feedback
                 updateHUD(localPlayerStats.magazine, localPlayerStats.ammo);
                 checkReloadPrompt(); // Check if empty mag prompt needed now
            }

            // Muzzle flash effect
            if (muzzleFlash) {
                muzzleFlash.intensity = 2.0; // Turn flash on
                setTimeout(() => { muzzleFlash.intensity = 0; }, 60); // Turn off after short duration
            }
            // TODO: Add recoil effect, sound effect
        }

        // Shows the scoreboard
        function showScoreboard() {
            if (!localPlayerId) return; // Don't show if not connected
            updateScoreboard(); // Update data before showing
            scoreboardElement.style.display = 'block';
        }

        // Hides the scoreboard
        function hideScoreboard() {
            scoreboardElement.style.display = 'none';
        }

        // Updates the scoreboard table content
        function updateScoreboard() {
            if (!scoreboardTableBody) return;
            scoreboardTableBody.innerHTML = ''; // Clear previous entries

            // Create a list of players including local player
            const playerList = [];
            if (localPlayerId) {
                // Get local player's name (might be from init or from players object if updated)
                 const localName = localPlayerStats.name || players[localPlayerId]?.name || "You";
                playerList.push({
                    id: localPlayerId,
                    name: localName,
                    kills: localPlayerStats.kills,
                    deaths: localPlayerStats.deaths,
                    isLocal: true
                });
            }
            // Add other players from the players object
            for (const id in players) {
                if (id !== localPlayerId) {
                    const p = players[id];
                    playerList.push({
                        id: id,
                        name: p.name || `Player_${id.substring(0, 4)}`, // Fallback name
                        kills: p.kills,
                        deaths: p.deaths,
                        isLocal: false
                    });
                }
            }

            // Sort players by kills (descending)
            playerList.sort((a, b) => b.kills - a.kills);

            // Populate the HTML table
            playerList.forEach(p => {
                const row = scoreboardTableBody.insertRow();
                if (p.isLocal) {
                    row.classList.add('local-player'); // Highlight local player
                }
                row.insertCell(0).textContent = p.name;
                row.insertCell(1).textContent = p.kills;
                row.insertCell(2).textContent = p.deaths;
            });
        }

        // Handles window resize events
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- Movement and Collision Variables ---
        const moveDirection = new THREE.Vector3(); // Intended move direction (WASD)
        const rightDirection = new THREE.Vector3(); // Vector pointing right relative to camera yaw
        const forwardDirection = new THREE.Vector3(); // Vector pointing forward relative to camera yaw
        const playerCollider = new THREE.Box3(); // Player's collision box (simplified)
        const collisionCheckVector = new THREE.Vector3(); // Helper vector for collision checks

        // --- Main Animation Loop ---
        function animate() {
            requestAnimationFrame(animate); // Schedule next frame
            const delta = Math.min(clock.getDelta(), 0.1); // Get time since last frame, capped

            // Update projectiles (client-side movement)
            for (const id in projectiles) {
                const p = projectiles[id];
                p.mesh.position.x += p.vx * delta;
                p.mesh.position.y += p.vy * delta;
                p.mesh.position.z += p.vz * delta;
                // Basic client-side cleanup for old projectiles
                if (Date.now() - p.spawnTime > 2500) { // Slightly longer than server lifetime
                    removeProjectile(id);
                }
            }

            // Update reload progress bar if reloading
            if (isReloading) {
                updateReloadProgress(delta);
            }

            // Update respawn timer and death screen effects
            if (isDead && respawnCountdown > 0) {
                respawnCountdown -= delta;
                respawnTimerElement.textContent = `Respawn in: ${Math.max(0, Math.ceil(respawnCountdown))}s`;
                // Simple camera drop effect on death
                const playerObject = controls.getObject();
                if (playerObject.position.y > 0.5) {
                    playerObject.position.y -= 2.0 * delta * Math.max(0.1, playerObject.position.y); // Faster drop initially
                }
            }

            // --- Local Player Movement and Collision ---
            if (controls.isLocked === true && localPlayerId && !isDead) { // Move only if cursor locked, connected, and alive
                const playerObject = controls.getObject(); // The camera/controls group

                // --- Vertical Movement (Gravity & Jump) ---
                playerVelocity.y -= gravity * delta; // Apply gravity
                playerObject.position.y += playerVelocity.y * delta; // Apply vertical velocity

                // Simple ground collision
                if (playerObject.position.y < playerEyeLevel) {
                    playerVelocity.y = 0; // Stop falling
                    playerObject.position.y = playerEyeLevel; // Snap to ground
                    canJump = true; // Allow jumping again
                }

                // --- Horizontal Movement (WASD) ---
                // Apply friction/damping
                playerVelocity.x -= playerVelocity.x * 10.0 * delta;
                playerVelocity.z -= playerVelocity.z * 10.0 * delta;

                // Calculate movement direction based on input keys
                moveDirection.z = Number(moveForward) - Number(moveBackward); // +1 forward, -1 backward
                moveDirection.x = Number(moveRight) - Number(moveLeft);     // +1 right, -1 left
                moveDirection.normalize(); // Prevent faster diagonal movement

                // Get camera's forward and right directions (ignoring pitch)
                camera.getWorldDirection(forwardDirection);
                forwardDirection.y = 0; // Project onto XZ plane
                forwardDirection.normalize();
                rightDirection.crossVectors(camera.up, forwardDirection).normalize(); // Calculate right vector

                // Calculate target velocity based on input and directions
                const targetVelocityX = (forwardDirection.x * moveDirection.z + rightDirection.x * moveDirection.x) * playerSpeed;
                const targetVelocityZ = (forwardDirection.z * moveDirection.z + rightDirection.z * moveDirection.x) * playerSpeed;

                // Smoothly accelerate/decelerate towards target velocity
                const accelerationFactor = delta * 10.0; // Controls how quickly player reaches full speed
                playerVelocity.x = THREE.MathUtils.lerp(playerVelocity.x, targetVelocityX, accelerationFactor);
                playerVelocity.z = THREE.MathUtils.lerp(playerVelocity.z, targetVelocityZ, accelerationFactor);

                // Calculate movement vector for this frame
                const moveX = playerVelocity.x * delta;
                const moveZ = playerVelocity.z * delta;

                // --- Collision Detection BEFORE Applying Movement ---
                let collisionX = false;
                let collisionZ = false;

                // Update player's collider based on *current* position
                playerCollider.setFromCenterAndSize(
                    playerObject.position,
                    new THREE.Vector3(playerRadius * 2, playerHeight, playerRadius * 2) // Use physics radius
                );

                // 1. Collision with obstacles (boxes)
                obstacles.forEach(obstacle => {
                    // Check collision if moving along X
                    const colliderX = playerCollider.clone().translate(new THREE.Vector3(moveX, 0, 0));
                    if (colliderX.intersectsBox(obstacle.userData.boundingBox)) {
                        collisionX = true;
                    }
                    // Check collision if moving along Z
                    const colliderZ = playerCollider.clone().translate(new THREE.Vector3(0, 0, moveZ));
                    if (colliderZ.intersectsBox(obstacle.userData.boundingBox)) {
                        collisionZ = true;
                    }
                });

                // 2. Collision with other players (simple distance check)
                for (const pId in players) {
                    if (pId === localPlayerId || !players[pId].mesh.visible) continue; // Skip self and dead players

                    const otherPlayerPos = players[pId].mesh.position; // Feet position of other player
                    const collisionRadiusSq = (playerRadius * 2.5) ** 2; // Use physics radius for player-player

                    // Check potential collision along X
                    collisionCheckVector.copy(playerObject.position).add(new THREE.Vector3(moveX, 0, 0));
                    if (collisionCheckVector.distanceToSquared(otherPlayerPos) < collisionRadiusSq) {
                        collisionX = true;
                    }
                    // Check potential collision along Z
                    collisionCheckVector.copy(playerObject.position).add(new THREE.Vector3(0, 0, moveZ));
                    if (collisionCheckVector.distanceToSquared(otherPlayerPos) < collisionRadiusSq) {
                        collisionZ = true;
                    }
                }

                // --- Apply Movement (Slide along walls) ---
                if (!collisionX) {
                    playerObject.position.x += moveX; // Apply X movement if no collision
                } else {
                    playerVelocity.x = 0; // Stop X velocity on collision
                }
                if (!collisionZ) {
                    playerObject.position.z += moveZ; // Apply Z movement if no collision
                } else {
                    playerVelocity.z = 0; // Stop Z velocity on collision
                }

                // --- Send Player Update to Server ---
                // (Could be optimized to send less frequently or only on significant changes)
                if (ws && ws.readyState === WebSocket.OPEN) {
                    const controlObject = controls.getObject();
                    const yaw = controlObject.rotation.y;
                    let pitch = 0;
                    // Safely get pitch from camera (first child of controls object)
                    if (controlObject.children && controlObject.children.length > 0 && controlObject.children[0]) {
                        pitch = controlObject.children[0].rotation.x;
                    }

                    ws.send(JSON.stringify({
                        type: 'player_update',
                        payload: {
                            // Server uses x, z and sets y=1. Send current calculated position.
                            position: { x: playerObject.position.x, y: 1.0, z: playerObject.position.z },
                            rotation: { pitch: pitch, yaw: yaw }
                        }
                    }));
                }
            }

            // Update labels for remote players
            for (const id in players) {
                if (id !== localPlayerId && players[id].mesh.visible) { // Update only visible remote players
                    updatePlayerLabel(players[id], players[id].health);
                }
            }

            // Render the scene
            renderer.render(scene, camera);
        }

    </script>
</body>
</html>